<!doctype html public '-//W3C//DTD HTML 4.0 Transitional //EN'>
<html>
<head>
<title>7.Customizing Concurrency Classes</title>
<meta charset='UTF-8' />
<meta name='generator' content='EverEdit' />
<link href='D:\EverEdit\mode\markdown\default.css' rel='stylesheet'></link>
<link href='D:\EverEdit\mode\markdown\prettify.css' rel='stylesheet'></link>
<script type='text/javascript' src='D:\EverEdit\mode\markdown\prettify.js'></script>
<script type='text/javascript' src='D:\EverEdit\mode\markdown\jquery-1.10.2.min.js'></script>
<script type='text/javascript' src='D:\EverEdit\mode\markdown\toc.js'></script>
</head>
<body>
<div id='generated-toc'></div>
<h2>Customizing the ThreadPoolExecutor class</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main clas of the example. It creates a custom executor and executes 10 tasks in it
 *
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) {

        /*
         * Creation of the custom executor
         */
        MyExecutor myExecutor=new MyExecutor(2, 4, 1000, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;Runnable&gt;());

        /*
         * Create a list to store the objects to control the execution of the tasks 
         */
        List&lt;Future&lt;String&gt;&gt; results=new ArrayList&lt;&gt;();

        /*
         * Create and submit to the executor 10 tasks 
         */
        for (int i=0; i&lt;10; i++) {
            SleepTwoSecondsTask task=new SleepTwoSecondsTask();
            Future&lt;String&gt; result=myExecutor.submit(task);
            results.add(result);
        }

        /*
         * Get the result of the execution of the first five tasks 
         */
        for (int i=0; i&lt;5; i++){
            try {
                String result=results.get(i).get();
                System.out.printf("Main: Result for Task %d : %s\n",i,result);
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }

        /*
         * Call the shutdown method 
         */
        myExecutor.shutdown();

        /*
         * Get the results of the execution of the last five tasks
         */
        for (int i=5; i&lt;10; i++){
            try {
                String result=results.get(i).get();
                System.out.printf("Main: Result for Task %d : %s\n",i,result);
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }

        /*
         * Wait for the finalization of the Executor
         */
        try {
            myExecutor.awaitTermination(1, TimeUnit.DAYS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        /*
         * Write a message indicating the end of the program
         */
        System.out.printf("Main: End of the program.\n");
    }

}
</code></pre>

<ul>
<li>MyExecutor.java</li>
</ul>

<pre><code class="java">/**
 * This class extends the ThreadPoolExecutor class to implement a customized executor.
 * It overrides the shutdown(), shutdownNow(), beforeExecute() and afterExecute() to
 * show statistics about the tasks executed by the Executor
 * 
 */
public class MyExecutorMyExecutor.java
 extends ThreadPoolExecutor {

    /**
     * A HashMap to store the start date of the tasks executed by the executor. When 
     * a task finish, it calculates the difference between the start date and the end date
     * to show the duration of the task
     */
    private ConcurrentHashMap&lt;String, Date&gt; startTimes;

    /**
     * Constructor of the executor. Call the parent constructor and initializes the HashMap
     * @param corePoolSize Number of threads to keep in the pool
     * @param maximumPoolSize Maximum number of threads in the pool
     * @param keepAliveTime Maximum time that threads can be idle
     * @param unit Unit of time of the keepAliveTime parameter
     * @param workQueue Queue where the submited tasks will be stored
     */
    public MyExecutor(int corePoolSize, int maximumPoolSize,
            long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
        startTimes=new ConcurrentHashMap&lt;&gt;();
    }

    /**
     * This method is called to finish the execution of the Executor. We write statistics
     * about the tasks executed in it
     */
    @Override
    public void shutdown() {
        System.out.printf("MyExecutor: Going to shutdown.\n");
        System.out.printf("MyExecutor: Executed tasks: %d\n",getCompletedTaskCount());
        System.out.printf("MyExecutor: Running tasks: %d\n",getActiveCount());
        System.out.printf("MyExecutor: Pending tasks: %d\n",getQueue().size());
        super.shutdown();
    }

    /**
     * This method is called to finish the execution of the Executor immediately. We write statistics
     * about the tasks executed in it
     */
    @Override
    public List&lt;Runnable&gt; shutdownNow() {
        System.out.printf("MyExecutor: Going to immediately shutdown.\n");
        System.out.printf("MyExecutor: Executed tasks: %d\n",getCompletedTaskCount());
        System.out.printf("MyExecutor: Running tasks: %d\n",getActiveCount());
        System.out.printf("MyExecutor: Pending tasks: %d\n",getQueue().size());
        return super.shutdownNow();
    }

    /**
     * This method is executed before the execution of a task. We store the start date in the HashMap
     */
    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        System.out.printf("MyExecutor: A task is beginning: %s : %s\n",t.getName(),r.hashCode());
        startTimes.put(String.valueOf(r.hashCode()), new Date());
    }

    /**
     * This method is executed after the execution of a task. We calculate the execution time of the task
     */
    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        Future&lt;?&gt; result=(Future&lt;?&gt;)r;
        try {
            System.out.printf("*********************************\n");
            System.out.printf("MyExecutor: A task is finishing.\n");
            System.out.printf("MyExecutor: Result: %s\n",result.get());
            Date startDate=startTimes.remove(String.valueOf(r.hashCode()));
            Date finishDate=new Date();
            long diff=finishDate.getTime()-startDate.getTime();
            System.out.printf("MyExecutor: Duration: %d\n",diff);
            System.out.printf("*********************************\n");
        } catch (InterruptedException  | ExecutionException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

<ul>
<li>SleepTwoSecondsTask.java</li>
</ul>

<pre><code class="java">/**
 * Task implemented to test the customized executor
 *
 */
public class SleepTwoSecondsTask implements Callable&lt;String&gt; {

    /**
     * Main method of the tasks. It only sleeps the current thread for two seconds
     */
    public String call() throws Exception {
        TimeUnit.SECONDS.sleep(2);
        return new Date().toString();
    }

}</code></pre>

<ul>
<li>输出结果:  继承了<code>ThreadPoolExecutor</code>,然后重写了四个方法</li>
</ul>

<p>ThreadPoolExecutor class and overriding four of its methods. The  beforeExecute()
and  afterExecute() methods were used to calculate the execution time of a task. The
beforeExecute() method is executed before the execution of a task. In this case, we have
used  HashMap to store in it the start date of the task. The  afterExecute() method is
executed after the execution of a task. You get  startTime of the task that has finished from
HashMap and then, calculate the difference between the actual date and that date to get the
execution time of the task. You have also overridden the  shutdown() and  shutdownNow()
methods to write statistics about the tasks executed in the executor to the console:</p>

<ul>
<li>The executed tasks, using the  getCompletedTaskCount() method</li>
<li>The tasks that are running at this time, using the  getActiveCount() method
The pending tasks, using the  size() method of the blocking queue where the executor
stores the pending tasks. The  SleepTwoSecondsTask class that implements the  Callable
interface puts its execution thread to sleep for 2 seconds and the  Main class, where you send
10 tasks to your executor that uses it and the other classes to demo their features.</li>
</ul>

<p>Execute the program and you will see how the program shows the time span of each task that
is running and the statistics of the executor upon calling the  shutdown() method.</p>

<h2>Implementing a priority-based Executor class</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main method of the class. It creates an Executor with a PriorityQueue as working queue and then
 * sends various tasks with different priorities to check that they are executed in the correct order
 *
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) {
        /*
         * Create an executor with a PriorityBlockingQueue as the structure to store the tasks
         */
        ThreadPoolExecutor executor=new ThreadPoolExecutor(2,2,1,TimeUnit.SECONDS,new PriorityBlockingQueue&lt;Runnable&gt;());

        /*
         * Send four task to the executor
         */
        for (int i=0; i&lt;4; i++){
            MyPriorityTask task=new MyPriorityTask("Task "+i,i);
            executor.execute(task);
        }

        /*
         * sleep the thread during one second
         */
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        /*
         * Send four tasks to the executor
         */
        for (int i=4; i&lt;8; i++) {
            MyPriorityTask task=new MyPriorityTask("Task "+i,i);
            executor.execute(task);         
        }

        /*
         * Shutdown the executor
         */
        executor.shutdown();

        /*
         * Wait for the finalization of the executor
         */
        try {
            executor.awaitTermination(1, TimeUnit.DAYS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        /*
         * Write a message to the console indicating the end of the program
         */
        System.out.printf("Main: End of the program.\n");
    }

}</code></pre>

<ul>
<li>MyPriorityTask.java</li>
</ul>

<pre><code class="java">/**
 * This is the base class to implement a priority-based executor. It implements the base for the priority tasks.
 * They are based on the Runnable interface and implement the Comparable interface. 
 * If a task has a higher value of its priority attribute, it will be stored before in the priority queue and
 * it will be executed before
 *
 */
public class MyPriorityTask implements Runnable, Comparable&lt;MyPriorityTask&gt; {

    /**
     * This attribute stores the priority of the task
     */
    private int priority;

    /**
     * This attribute stores the name of the task
     */
    private String name;

    /**
     * Constructor of the task. It initialize its attributes
     * @param name Name of the task
     * @param priority Priority of the task
     */
    public MyPriorityTask(String name, int priority) {
        this.name=name;
        this.priority=priority;
    }

    /**
     * Method that returns the priority of the task
     * @return the priority of the task
     */
    public int getPriority(){
        return priority;
    }

    /**
     * Method that compares the priorities of two tasks. The task with higher priority value will
     * be stored before in the list and it will be executed before
     */
    @Override
    public int compareTo(MyPriorityTask o) {
        if (this.getPriority() &lt; o.getPriority()) {
            return 1;
        }

        if (this.getPriority() &gt; o.getPriority()) {
            return -1;
        }

        return 0;
    }

    /**
     * Main method of the task. It only writes a message to the console. It will be overridden by the real tasks
     */
    @Override
    public void run() {
        System.out.printf("MyPriorityTask: %s Priority : %d\n",name,priority);
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }   
    }

}</code></pre>

<ul>
<li>输出结果: new一个<code>PriorityBlockingQueue</code>当作<code>ThreadPoolExecutor</code>的构造参数,这样就可以自定义优先级线程池了</li>
</ul>

<p>With the Executor framework, you only have to implement your tasks and send them to the
executor. The executor is responsible for the creation and execution of the threads that
execute your tasks.</p>

<p>Internally, an executor uses a blocking queue to store pending tasks. These are stored in the
order of their arrival to the executor. One possible alternative is the use of a priority queue
to store new tasks. In this way, if a new task with high priority arrives to the executor, it will
be executed before other threads that have already been waiting for a thread to execute, but
have lower priority.</p>

<p>You have implemented the  MyPriorityTask class that implements the  Runnable
interface, to be a task, and the  Comparable interface, to be stored in the priority queue.
This class has a  Priority attribute that is used to store the priority of the tasks. If a task
has a higher value for this attribute, it will be executed earlier. The  compareTo() method
determines the order of the tasks in the priority queue. In the  Main class, you sent eight tasks
to the executor with different priorities. The first tasks you sent to the executor are the first
tasks that are executed. As the executor is idle waiting for tasks to be executed, and as the
first tasks arrive to the executor, it executes them immediately. You have created the executor
with two execution threads, so the first two tasks will be the first ones that are executed. Then,
the rest of the tasks are executed based on their priority.</p>

<ul>
<li>其他实现,比如<code>ScheduledThreadPoolExecutor</code></li>
</ul>

<p>You can configure  Executor to use any implementation of the  BlockingQueue interface.
One interesting implementation is  DelayQueue . This class is used to store elements with a
delayed activation. It provides methods that only return the active objects. You can use this
class to implement your own version of the  ScheduledThreadPoolExecutor class</p>

<h2>Implementing the ThreadFactory interface to generate custom threads</h2>

<ul>
<li>工厂模式</li>
</ul>

<p>The factory pattern is a widely used design pattern in the object-oriented programming world.
It is a creational pattern and its objective is to develop a class whose mission will be creating
objects of one or several classes. Then, when we want to create an object of one of those
classes, we use the factory instead of using the new operator.</p>

<ul>
<li>With this factory, we centralize the creation of objects gaining an advantage of easily
changing the class of objects created or the way we create these objects that are
easily limiting the creation of objects for limited resources. For example, we can only
have N objects of a type that is easily generating statistical data about the creation
of objects.</li>
</ul>

<p>Java provides the  ThreadFactory interface to implement a  Thread object factory. Some
advanced utilities of the Java concurrency API, as the Executor framework or the Fork/Join
framework, use thread factories to create threads.
Another example of the factory pattern in the Java Concurrency API is the  Executors class.
It provides a lot of methods to create different kinds of  Executor objects.</p>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example. Creates a factory, a MyThread object to execute a Task object
 * and executes the Thread
 *  
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) throws Exception {
        /*
         * Create a Factory
         */
        MyThreadFactory myFactory=new MyThreadFactory("MyThreadFactory");

        /*
         * Crate a Task
         */
        MyTask task=new MyTask();

        /*
         * Create a Thread using the Factory to execute the Task
         */
        Thread thread=myFactory.newThread(task);

        /*
         * Start the Thread
         */
        thread.start();

        /*
         * Wait for the finalization of the Thread
         */
        thread.join();

        /*
         * Write the thread info to the console
         */
        System.out.printf("Main: Thread information.\n");
        System.out.printf("%s\n",thread);
        System.out.printf("Main: End of the example.\n");

    }

}</code></pre>

<ul>
<li>MyTask.java</li>
</ul>

<pre><code class="java">/**
 * Task to be executed in the MyThread threads
 *
 */
public class MyTask implements Runnable {

    /**
     * Main method of the Thread. Sleeps the thread during two seconds
     */
    @Override
    public void run() {
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>

<ul>
<li>MyThread.java</li>
</ul>

<pre><code class="java">/**
 * This class extends the Thread class calculating its execution time
 *
 */
public class MyThread extends Thread {

    /**
     * Creation date of the Thread
     */
    private Date creationDate;

    /**
     * Start date of the Thread
     */
    private Date startDate;

    /**
     * Finish date of the Thread
     */
    private Date finishDate;

    /**
     * Constructor of the class. Use the constructor of the Thread class and storeas the creation date of the Thread
     * @param target Task to execute
     * @param name Name of the thread
     */
    public MyThread(Runnable target, String name ){
        super(target,name);
        setCreationDate();
    }

    /**
     * Main method of the thread. Stores the start date and the finish date and calls the run() method of the parent class
     */
    @Override
    public void run() {
        setStartDate();
        super.run();
        setFinishDate();
    }

    /**
     * Method that establish the value of the creation date
     */
    public void setCreationDate() {
        creationDate=new Date();
    }

    /**
     * Method that establish the value of the start date
     */
    public void setStartDate() {
        startDate=new Date();
    }

    /**
     * Method that establish the value of the finish date
     */
    public void setFinishDate() {
        finishDate=new Date();
    }

    /**
     * Method that calculates the execution time of the thread
     * @return The execution time of the thread
     */
    public long getExecutionTime() {
        return finishDate.getTime()-startDate.getTime();
    }

    /**
     * Method that writes information about the thread
     */
    @Override
    public String toString(){
        StringBuilder buffer=new StringBuilder();
        buffer.append(getName());
        buffer.append(": ");
        buffer.append(" Creation Date: ");
        buffer.append(creationDate);
        buffer.append(" : Running time: ");
        buffer.append(getExecutionTime());
        buffer.append(" Milliseconds.");
        return buffer.toString();
    }
}</code></pre>

<ul>
<li>MyThreadFactory.java</li>
</ul>

<pre><code class="java">/**
 * Factory to create MyThread objects
 *
 */
public class MyThreadFactory implements ThreadFactory {

    /**
     * Attribute to store the number of threads created in this factory
     */
    private int counter;

    /**
     * String to create the name of the threads created with this factory
     */
    private String prefix;

    /**
     * Constructor of the class. Initialize its parameters
     * @param prefix First part of the name of the threads created with this factory
     */
    public MyThreadFactory (String prefix) {
        this.prefix=prefix;
        counter=1;
    }

    /**
     * Method that creates a new MyThread thread
     */
    @Override
    public Thread newThread(Runnable r) {
        MyThread myThread=new MyThread(r,prefix+"-"+counter);
        counter++;
        return myThread;
    }

}</code></pre>

<ul>
<li>输出结果: 实现<code>ThreadFactory</code>,重写了<code>newThread()</code>方法</li>
</ul>

<p>In this recipe, you have implemented a custom  MyThread class extending the  Thread class.
The class has three attributes to store the creation date, the start date of its execution, and
the end date of its execution. Using the start date and the end date attributes, you have
implemented the  getExecutionTime() method that returns the time that the thread has
been executing its task. Finally, you have overridden the  toString() method to generate
information about a thread.</p>

<p>Once you had your own thread class, you have implemented a factory to create objects of
that class implementing the  ThreadFactory interface. It's not mandatory to make use of
the interface if you're going to use your factory as an independent object, but if you want
to use this factory with other classes of the Java concurrency API, you must construct your
factory by implementing that interface. The  ThreadFactory interface only has one method,
the  newThread() method that receives a  Runnable object as a parameter and returns a
Thread object to execute that  Runnable object. In your case, you return a  MyThread object.</p>

<p>To check these two classes, you have implemented the  MyTask class that implements the
Runnable object. This is the task to be executed in threads managed by the  MyThread
object. A  MyTask instance puts its execution thread to sleep for 2 seconds.</p>

<h2>Using our ThreadFactory in an Executor object</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example. Creates a Factory, an Executor using
 * that factory and submits a task to the executor
 *
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) throws Exception {

        /*
         * Create a new MyThreadFactory object
         */
        MyThreadFactory threadFactory=new MyThreadFactory("MyThreadFactory");

        /*
         * Create a new ThreadPoolExecutor and configure it for use the 
         * MyThreadFactoryObject created before as the factory to create the threads
         */
        ExecutorService executor=Executors.newCachedThreadPool(threadFactory);

        /*
         * Create a new Task object
         */
        MyTask task=new MyTask();

        /*
         * Submit the task 
         */
        executor.submit(task);

        /*
         * Shutdown the executor
         */
        executor.shutdown();

        /*
         * Wait for the finalization of the executor
         */
        executor.awaitTermination(1, TimeUnit.DAYS);

        /*
         * Write a message indicating the end of the program
         */
        System.out.printf("Main: End of the program.\n");



    }

}</code></pre>

<ul>
<li>MyTask.java</li>
</ul>

<pre><code class="java">/**
 * Task to check the MyThread and MyThreadFactory classes. It sleeps
 * the thread for two seconds
 *
 */
public class MyTask implements Runnable {

    /**
     * Main method of the task. It sleeps the thread for two seconds
     */
    @Override
    public void run() {
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}</code></pre>

<ul>
<li>MyThread.java</li>
</ul>

<pre><code class="java">/**
 * This class implement your own Thread. It stores the creation date, the
 * start date and the finish date of the thread. It provides a mehtod that
 * calculates the execution time of the thread. Overrides the toString() method
 * to return information about the creationDate and the execution time of the thread
 */
public class MyThread extends Thread {

    /**
     * Creation date of the thread
     */
    private Date creationDate;

    /**
     * Start date of the thread
     */
    private Date startDate;

    /**
     * Finish date of the thread
     */
    private Date finishDate;

    /**
     * Constructor of the class. It establishes the value of the creation date attribute
     * @param target Runnable object that this thread is going to execute
     * @param name Name of the thread
     */
    public MyThread(Runnable target, String name ){
        super(target,name);
        setCreationDate();
    }

    /**
     * Main method of the thread. Stores the start and finish date of the thread and calls
     * the run() method of its parent class
     */
    @Override
    public void run() {
        setStartDate();
        super.run();
        setFinishDate();
        System.out.printf("Thread: %s\n",toString());
    }

    /**
     * Method that establish the creation date of the thread
     */
    public void setCreationDate() {
        creationDate=new Date();
    }

    /**
     * Method that establish the start date of the thread
     */
    public void setStartDate() {
        startDate=new Date();
    }

    /**
     * Method that establish the finish date of the thread
     */
    public void setFinishDate() {
        finishDate=new Date();
    }

    /**
     * Method that calculates the execution time of the thread as the difference
     * between the finish date and the start date.
     * @return
     */
    public long getExecutionTime() {
        long ret;
        ret=finishDate.getTime()-startDate.getTime();
        return ret;
    }

    /**
     * Method that generates a String with information about the creation date and the
     * execution time of the thread
     */
    public String toString(){
        StringBuffer buffer=new StringBuffer();
        buffer.append(getName());
        buffer.append(": ");
        buffer.append(" Creation Date: ");
        buffer.append(creationDate);
        buffer.append(" : Running time: ");
        buffer.append(getExecutionTime());
        buffer.append(" Milliseconds.");
        return buffer.toString();
    }
}</code></pre>

<ul>
<li>MyThreadFactory.java</li>
</ul>

<pre><code class="java">
/**
 * Factory to create our kind of threads. Implement the
 * ThreadFactory interface.  
 *
 */
public class MyThreadFactoryMyThreadFactory.java implements ThreadFactory {

    /**
     * Attribute to store the number of threads created by the Factory
     */
    private int counter;

    /**
     * Prefix to use in the name of the threads created by the Factory
     */
    private String prefix;

    /**
     * Constructor of the class. Initializes its attributes
     * @param prefix Prefix to use in the name of the threads
     */
    public MyThreadFactory (String prefix) {
        this.prefix=prefix;
        counter=1;
    }

    /**
     * Method that create a new MyThread object to execute the Runnable
     * object that receives as parameter 
     */
    @Override
    public Thread newThread(Runnable r) {
        MyThread myThread=new MyThread(r,prefix+"-"+counter);
        counter++;
        return myThread;
    }
}</code></pre>

<ul>
<li>输出结果: 和上面创建<code>ThreadFactory</code>的方式不一样,这个示例是用的是<code>Executors.newCachedThreadPool(threadFactory);</code>,threadFactory变量是自定义的<code>MyThreadFactory threadFactory=new MyThreadFactory("MyThreadFactory");</code></li>
</ul>

<h2>Customizing tasks running in a scheduled thread pool</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example. Creates a MyScheduledThreadPoolExecutor and
 * executes a delayed task and a periodic task in it.
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) throws Exception {

        /*
         * Create a MyScheduledThreadPool object
         */
        MyScheduledThreadPoolExecutor executor=new MyScheduledThreadPoolExecutor(2);

        /*
         * Create a task object  
         */
        Task task=new Task();

        /*
         * Write the start date of the execution
         */
        System.out.printf("Main: %s\n",new Date());

        /*
         * Send to the executor a delayed task. It will be executed after 1 second of delay
         */
        executor.schedule(task, 1, TimeUnit.SECONDS);

        /*
         * Sleeps the thread three seconds 
         */
        TimeUnit.SECONDS.sleep(3);

        /*
         * Create another task
         */
        task=new Task();

        /*
         * Write the actual date again
         */
        System.out.printf("Main: %s\n",new Date());

        /*
         * Send to the executor a delayed task. It will begin its execution after 1 second of dealy
         * and then it will be executed every three seconds
         */
        executor.scheduleAtFixedRate(task, 1, 3, TimeUnit.SECONDS);

        /*
         * Sleep the thread during ten seconds
         */
        TimeUnit.SECONDS.sleep(10);

        /*
         * Shutdown the executor
         */
        executor.shutdown();

        /*
         * Wait for the finalization of the executor
         */
        executor.awaitTermination(1, TimeUnit.DAYS);

        /*
         * Write a message indicating the end of the program
         */
        System.out.printf("Main: End of the program.\n");
    }

}</code></pre>

<ul>
<li>MyScheduledTask.java</li>
</ul>

<pre><code class="java">/**
 * 
 * This class implements an scheduled task to be execute in a scheduled thread pool executor. It's
 * a parameterized class where V is the type of data that will be returned by the task. 
 * 
 * An scheduled thread pool executor can execute two kinds of tasks:
 *      Delayed Tasks: This kind of tasks are executed once after a period of time.
 *      Periodic Tasks: This kind of tasks are executed from time to time
 * @param &lt;V&gt; Type of data that will be returned by the task
 * 
 */
public class MyScheduledTask&lt;V&gt; extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; {

    /**
     * Attribute to store the task that will be used to create a MyScheduledTask
     */
    private RunnableScheduledFuture&lt;V&gt; task;

    /**
     * ScheduledThreadPoolExecutor that is going to execute the task
     */
    private ScheduledThreadPoolExecutor executor;

    /**
     * Period of time between two executions of the task
     */
    private long period;

    /**
     * Date when will begin the next execution of the task
     */
    private long startDate;

    /**
     * Constructor of the class. It initializes the attributes of the class
     * @param runnable Runnable submitted to be executed by the task
     * @param result Result that will be returned by the task
     * @param task Task that will execute the Runnable object
     * @param executor Executor that is going to execute the task
     */
    public MyScheduledTask(Runnable runnable, V result, RunnableScheduledFuture&lt;V&gt; task, ScheduledThreadPoolExecutor executor) {
        super(runnable, result);
        this.task=task;
        this.executor=executor;
    }

    /**
     * Method that returns the reminder for the next execution of the task. If is 
     * a delayed task, returns the delay of the original task. Else, return the difference
     * between the startDate attribute and the actual date.
     * @param unit TimeUnit to return the result
     */
    @Override
    public long getDelay(TimeUnit unit) {
        if (!isPeriodic()) {
            return task.getDelay(unit);
        } else {
            if (startDate==0){
                return task.getDelay(unit);
            } else {
                Date now=new Date();
                long delay=startDate-now.getTime();
                return unit.convert(delay, TimeUnit.MILLISECONDS);
            }
        }
    }

    /**
     * Method to compare two tasks. It calls the compareTo() method of the original task
     */
    @Override
    public int compareTo(Delayed o) {
        return task.compareTo(o);
    }

    /**
     * Method that returns if the task is periodic or not. It calls the isPeriodic() method
     * of the original task
     */
    @Override
    public boolean isPeriodic() {
        return task.isPeriodic();
    }


    /**
     * Method that executes the task. If it's a periodic task, it updates the 
     * start date of the task and store in the queue of the executor the task to
     * be executed again
     */
    @Override
    public void run() {
        if (isPeriodic() &amp;&amp; (!executor.isShutdown())) {
            Date now=new Date();
            startDate=now.getTime()+period;
            executor.getQueue().add(this);
        }
        System.out.printf("Pre-MyScheduledTask: %s\n",new Date());
        System.out.printf("MyScheduledTask: Is Periodic: %s\n",isPeriodic());
        super.runAndReset();
        System.out.printf("Post-MyScheduledTask: %s\n",new Date());
    }

    /**
     * Method that establish the period of the task for periodic tasks
     * @param period
     */
    public void setPeriod(long period) {
        this.period=period;
    }
}
</code></pre>

<ul>
<li>MyScheduledThreadPoolExecutor.java</li>
</ul>

<pre><code class="java">/**
 * Our implementation of an ScheduledThreadPoolExecutor two executes MyScheduledTasks tasks. It extends
 * the ScheduledThreadPoolExecutor class
 *
 */
public class MyScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {

    /**
     * Constructor of the class. Calls the constructor of its parent class using the super keyword
     * @param corePoolSize Number of threads to keep in the pool
     */
    public MyScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize);
    }


    /**
     * Method that converts a RunnableScheduledFuture task in a MyScheduledTask task
     */
    @Override
    protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable,
            RunnableScheduledFuture&lt;V&gt; task) {
        MyScheduledTask&lt;V&gt; myTask=new MyScheduledTask&lt;V&gt;(runnable, null, task,this);    
        return myTask;
    }


    /**
     * Method that schedule in the executor a periodic tasks. It calls the method of its parent class using
     * the super keyword and stores the period of the task.
     */
    @Override
    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
            long initialDelay, long period, TimeUnit unit) {
        ScheduledFuture&lt;?&gt; task= super.scheduleAtFixedRate(command, initialDelay, period, unit);
        MyScheduledTask&lt;?&gt; myTask=(MyScheduledTask&lt;?&gt;)task;
        myTask.setPeriod(TimeUnit.MILLISECONDS.convert(period,unit));
        return task;
    }

}</code></pre>

<ul>
<li>Task.java</li>
</ul>

<pre><code class="java">/**
 * Runnable object to check the MyScheduledTask and MyScheduledThreadPoolExecutor classes.
 *
 */
public class Task implements Runnable {

    /**
     * Main method of the task. Writes a message, sleeps the current thread for two seconds and
     * writes another message
     */
    @Override
    public void run() {
        System.out.printf("Task: Begin.\n");
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.printf("Task: End.\n");
    }

}</code></pre>

<ul>
<li>输出结果: 和第4章学习的<code>ScheduledThreadPoolExecutor</code>类似,只不过这里继承了额它,实现了<code>decorateTask()</code> 和<code>scheduleAtFixedRate()</code>方法</li>
</ul>

<p>In this recipe, you have implemented the  MyScheduledTask class to implement a custom
task that can execute on a  ScheduledThreadPoolExecutor executor. This class extends
the  FutureTask class and implements the  RunnableScheduledFuture interface. It
implements the  RunnableScheduledFuture interface, because all the tasks executed
in a scheduled executor must implement that interface and extend the  FutureTask
class, because this class provides valid implementations of the methods declared in the
RunnableScheduledFuture interface. All the interfaces and classes mentioned earlier are
parameterized classes, with the type of data that will be returned by the tasks.</p>

<p>To use a  MyScheduledTask task in a scheduled executor, you have overridden the
decorateTask() method in the  MyScheduledThreadPoolExecutor class. This
class extends the  ScheduledThreadPoolExecutor executor and that method
provides a mechanism to convert the default scheduled tasks implemented by the
ScheduledThreadPoolExecutor executor to  MyScheduledTask tasks. So, when you
implement your own version of scheduled tasks, you have to implement your own version
of a scheduled executor.</p>

<h2>Implementing the ThreadFactory interface to generate custom threads for the Fork/Join framework</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example. It creates an array of 100000 elements, initializes all
 * the elements to the 1 value, creates a new ForkJoinPool with the new 
 *
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) throws Exception {

        /*
         * Create a new MyWorkerThreadFactory
         */
        MyWorkerThreadFactory factory=new MyWorkerThreadFactory();

        /*
         * Create new ForkJoinPool, passing as parameter the factory created before
         */
        ForkJoinPool pool=new ForkJoinPool(4, factory, null, false);

        /*
         * Create and initializes the elements of the array
         */
        int array[]=new int[100000];

        for (int i=0; i&lt;array.length; i++){
            array[i]=1;
        }

        /*
         * Create a new Task to sum the elements of the array
         */
        MyRecursiveTask task=new MyRecursiveTask(array,0,array.length);

        /*
         * Send the task to the ForkJoinPool 
         */
        pool.execute(task);


        /*
         * Wait for the finalization of the task
         */
        task.join();

        /*
         * Shutdown the pool
         */
        pool.shutdown();

        /*
         * Wait for the finalization of the pool
         */
        pool.awaitTermination(1, TimeUnit.DAYS);

        /*
         * Write the result of the task
         */
        System.out.printf("Main: Result: %d\n",task.get());

        /*
         * Write a message indicating the end of the program
         */
        System.out.printf("Main: End of the program\n");
    }

}</code></pre>

<ul>
<li>MyRecursiveTask.java</li>
</ul>

<pre><code class="java">/**
 * Task that will be executed in the Fork/Join framework. It calculates 
 * the sum of all array elements
 *
 */
public class MyRecursiveTask extends RecursiveTask&lt;Integer&gt; {

    /**
     * Serial Version UID
     */
    private static final long serialVersionUID = 1L;

    /**
     * Array to be summed
     */
    private int array[];

    /**
     * Start and end positions of the part of the array to be summed by this task
     */
    private int start, end;

    /**
     * Constructor of the class. It initializes the  attributes of the task
     * @param array Array to be summed
     * @param start Start position of the block of the array to be summed by this task
     * @param end End position of the block of the array to be summed by this task
     */
    public MyRecursiveTask(int array[],int start, int end) {
        this.array=array;
        this.start=start;
        this.end=end;
    }

    /**
     * Main method of the task. If the task has less than 100 elements to sum, it calculates
     * the sum of these elements directly. Else, it creates two subtask to process the two
     * halves of the block.
     * 
     * It also calls the addTask() method of the thread that is executing the task to
     * updates its internal counter of tasks
     */
    @Override
    protected Integer compute() {
        Integer ret;
        MyWorkerThread thread=(MyWorkerThread)Thread.currentThread();
        thread.addTask();
        if (end-start&gt;100) {
            int mid=(start+end)/2;
            MyRecursiveTask task1=new MyRecursiveTask(array,start,mid);
            MyRecursiveTask task2=new MyRecursiveTask(array,mid,end);
            invokeAll(task1,task2);
            ret=addResults(task1,task2);
        } else {
            int add=0;
            for (int i=start; i&lt;end; i++) {
                add+=array[i];
            }
            ret=new Integer(add);
        }
        try {
            TimeUnit.MILLISECONDS.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return ret;
    }

    /**
     * Method that adds the results of the two subtasks create by this task
     * @param task1 First task
     * @param task2 Second task
     * @return The sum of the results of the two tasks
     */
    private Integer addResults(MyRecursiveTask task1, MyRecursiveTask task2) {
        int value;
        try {
            value = task1.get().intValue()+task2.get().intValue();
        } catch (InterruptedException e) {
            e.printStackTrace();
            value=0;
        } catch (ExecutionException e) {
            e.printStackTrace();
            value=0;
        }
        return new Integer(value);
    }

}</code></pre>

<ul>
<li>MyWorkerThread.java</li>
</ul>

<pre><code class="java">/**
 * This class implements a custom thread for the Fork/Join framework. It extends the
 * ForkJoinWorkerThread that is the default implementation of the threads that executes
 * the tasks in the Fork/Join Framework. This custom thread counts the number of tasks
 * executed in it
 *
 */
public class MyWorkerThread extends ForkJoinWorkerThread {

    /**
     * ThreadLocal attribute to store the number of tasks executed by each thread
     */
    private static ThreadLocal&lt;Integer&gt; taskCounter=new ThreadLocal&lt;&gt;();

    /**
     * Constructor of the class. It calls the constructor of its parent class using the
     * super keyword
     * @param pool ForkJoinPool where the thread will be executed
     */
    protected MyWorkerThread(ForkJoinPool pool) {
        super(pool);
    }

    /**
     * This method is called when a worker thread of the Fork/Join framework begins its execution.
     * It initializes its task counter
     */
    @Override
    protected void onStart() {
        super.onStart();
        System.out.printf("MyWorkerThread %d: Initializing task counter.\n",getId());
        taskCounter.set(0);
    }

    /**
     * This method is called when a worker thread of the Fork/Join framework ends its execution.
     * It writes in the console the value of the taskCounter attribute.
     */
    @Override
    protected void onTermination(Throwable exception) {
        System.out.printf("MyWorkerThread %d: %d\n",getId(),taskCounter.get());
        super.onTermination(exception);
    }

    /**
     * This method is called for each task to increment the task counter of the worker thread
     */
    public void addTask(){
        int counter=taskCounter.get().intValue();
        counter++;
        taskCounter.set(counter);
    }

}</code></pre>

<ul>
<li>MyWorkerThreadFactory.java </li>
</ul>

<pre><code class="java">/**
 * Factory to be used by the Fork/Join framework to create the worker threads. Implements
 * the ForkJoinWorkerThreadFactory interface
 *
 */
public class MyWorkerThreadFactory implements ForkJoinWorkerThreadFactory {

    /**
     * Method that creates a worker thread for the Fork/Join framework
     * @param pool ForkJoinPool where the thread will be executed
     * @return a MyWorkerThread thread
     */
    @Override
    public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
        return new MyWorkerThread(pool);
    }

}
</code></pre>

<ul>
<li>输出结果:  实现了<code>ForkJoinWorkerThreadFactory</code>,重写<code>newThread()</code>方法</li>
</ul>

<h2>Customizing tasks running in the Fork/Join framework</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example. It creates a ForkJoinPool and a 
 * Task and executes the task in the pool
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) throws Exception {

        /*
         * Create an array of 10000 elements
         */
        int array[]=new int[10000];

        /*
         * ForkJoinPool to execute the task 
         */
        ForkJoinPool pool=new ForkJoinPool();

        /*
         * Task to increment the elements of the array
         */
        Task task=new Task("Task",array,0,array.length);

        /*
         * Send the task to the pool
         */
        pool.invoke(task);

        /*
         * Shutdown the pool
         */
        pool.shutdown();

        /*
         * Write a message in the console
         */
        System.out.printf("Main: End of the program.\n");

    }

}
</code></pre>

<ul>
<li>MyWorkerTask.Java</li>
</ul>

<pre><code class="java">/**
 * This class extends the ForkJoinTask class to implement your own version of a task running 
 * in a ForkJoinPool of the Frok/Join framework. It's equivalent to the RecursiveAction and
 * Recursive classes. As the RecursiveAction class, it doesn't return any result
 *
 */
public abstract class MyWorkerTask extends ForkJoinTask&lt;Void&gt; {

    /**
     * Serial Version UID of the class
     */
    private static final long serialVersionUID = 1L;

    /**
     * Name of the task 
     */
    private String name;

    /**
     * Constructor of the class. Initializes its attributes 
     * @param name Name of the task
     */
    public MyWorkerTask(String name) {
        this.name=name;
    }

    /**
     * Method that returns the result of the task. In this case, as 
     * the task doesn't return a result, it returns a null value
     */
    @Override
    public Void getRawResult() {
        return null;
    }

    /**
     * Method that establish the result of the task. In this case, as
     * the task doesn't return a result, this method is empty
     */
    @Override
    protected void setRawResult(Void value) {

    }

    /**
     * Main method of the task. Is called by the Fork/Join pool. It calls
     * the compute() method that is an abstract method that have to be
     * implemented by the tasks that extend this class, calculating its execution
     * time and writing it in the console
     */
    @Override
    protected boolean exec() {
        Date startDate=new Date();
        compute();
        Date finishDate=new Date();
        long diff=finishDate.getTime()-startDate.getTime();
        System.out.printf("MyWorkerTask: %s : %d Milliseconds to complete.\n",name,diff);
        return true;
    }

    /**
     * Method that returns the name of the console
     * @return The name of the task
     */
    public String getName(){
        return name;
    }

    /**
     * Main method of the child tasks. It has to be overridden in the child classes 
     * and implement on it its main logic
     */
    protected abstract void compute();
}</code></pre>

<ul>
<li>Task.java</li>
</ul>

<pre><code class="java">/**
 * Task that extends the MyWorkerTask class to be executed
 * in a Fork/Join framework
 *
 */
public class Task extends MyWorkerTask {

    /**
     * Serival Version UID of the task
     */
    private static final long serialVersionUID = 1L;

    /**
     * Array of integers. This task will increment all the elements of the array
     */
    private int array[];
    /**
     * First element of the array that this task is going to increment
     */
    private int start;

    /**
     * Last element of the array that this task is going to increment
     */
    private int end;

    /**
     * Constructor of the class. It initializes its attributes
     * @param name Name of the task
     * @param array Array of elements that is going to be incremented
     * @param start First element of the array to be incremented by this task
     * @param end Last element of the array to be incremented by this task
     */
    public Task(String name, int array[], int start, int end){
        super(name);
        this.array=array;
        this.start=start;
        this.end=end;
    }

    /**
     * Main method of the task. If the task has to increment less that 100
     * elements, it increments them directly. Else, it divides the
     * operation in two subtasks
     */
    @Override
    protected void compute() {
        if (end-start&gt;100){
            int mid=(end+start)/2;
            Task task1=new Task(this.getName()+"1",array,start,mid);
            Task task2=new Task(this.getName()+"2",array,mid,end);
            invokeAll(task1,task2);
        } else {
            for (int i=start; i&lt;end; i++) {
                array[i]++;
            }           
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

}</code></pre>

<ul>
<li>输出结果: 创建一个抽象类,继承<code>ForkJoinTask&lt;Void&gt;</code></li>
</ul>

<h2>Customizing tasks running in the Fork/Join framework</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example
 *
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) {

        /*
         * Create a new MyLock object 
         */
        MyLock lock=new MyLock();

        /*
         * Create and run ten task objects
         */
        for (int i=0; i&lt;10; i++){
            Task task=new Task("Task-"+i,lock);
            Thread thread=new Thread(task);
            thread.start();
        }

        /*
         * The main thread also tries to get the lock
         */
        boolean value;
        do {
            try {
                value=lock.tryLock(1,TimeUnit.SECONDS);
                if (!value) {
                    System.out.printf("Main: Trying to get the Lock\n");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
                value=false;
            }
        } while (!value);

        /*
         * The main thread release the lock
         */
        System.out.printf("Main: Got the lock\n");
        lock.unlock();

        /*
         * Write a message in the console indicating the end of the program
         */
        System.out.printf("Main: End of the program\n");
    }

}</code></pre>

<ul>
<li>MyAbstractQueuedSynchronizer.java</li>
</ul>

<pre><code class="java">/**
 * This class extends the AbstractQueueSynchronizer class to implement
 * the basis of a Lock. Internally, it uses an AtomicInteger variable
 * to store the state of the lock. It also stores the current thread that
 * has the lock. The tryAcquire()  method and tryRelease() method
 * are the starting point for the Lock implementation
 *
 */
public class MyAbstractQueuedSynchronizer extends AbstractQueuedSynchronizer {

    /**
     * Serial version UID of the class
     */
    private static final long serialVersionUID = 1L;

    /**
     * Attribute that stores the state of the lock. 0 if it's free, 1 if it's busy
     */
    private AtomicInteger state;

    /**
     * Constructor of the class
     */
    public MyAbstractQueuedSynchronizer() {
        state=new AtomicInteger(0);
    }

    /**
     * This method try to acquire the control of the lock
     * @return true if the thread acquires the lock, false otherwise
     */
    @Override
    protected boolean tryAcquire(int arg) {
        return state.compareAndSet(0, 1);
    }

    /**
     * This method try to free the control of the lock
     * @return true if the thread releases the lock, false otherwise
     */
    @Override
    protected boolean tryRelease(int arg) {
        return state.compareAndSet(1, 0);
    }
}</code></pre>

<ul>
<li>MyLock.java</li>
</ul>

<pre><code class="java">/**
 * This class implements a basic Lock. It uses a myAbstractQueueSyncrhonized object
 * as the element from which implement the methods of the lock. 
 *
 */
public class MyLock implements Lock{

    /**
     * Synchronizer to implement the operations of the locks
     */
    private AbstractQueuedSynchronizer sync;

    /**
     * Constructor of the class. It initializes its attribute
     */
    public MyLock() {
        sync=new MyAbstractQueuedSynchronizer();
    }

    /**
     * Method that try to acquire the lock. If it can't, the thread
     * will be blocked until the thread that has it release the lock
     */
    @Override
    public void lock() {
        sync.acquire(1);
    }

    /**
     * Method that try to acquire the lock. If it can't, the thread will
     * be blocked until the thread that has it release the lock. The difference
     * with the lock() method is that in this case, the blocked threads can
     * be interrupted
     */
    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    /**
     * Method that try to acquire the lock. If it can, the method returns the true
     * value. It it can't, the method return the false value
     */
    @Override
    public boolean tryLock() {
        try {
            return sync.tryAcquireNanos(1, 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * Method that try to acquire the lock. If it can, the method returns the true value.
     * If it can't, wait the time specified as parameter and if the lock hasn't been
     * released, it returns the false value. It the lock is released in that period of time,
     * the thread acquires the lock and the method returns the true value
     */
    @Override
    public boolean tryLock(long time, TimeUnit unit)
            throws InterruptedException {
        return sync.tryAcquireNanos(1, TimeUnit.NANOSECONDS.convert(time, unit));
    }

    /**
     * Method that release the lock
     */
    @Override
    public void unlock() {
        sync.release(1);
    }

    /**
     * Method that creates a new condition for the lock
     */
    @Override
    public Condition newCondition() {
        return sync.new ConditionObject();
    }

}
</code></pre>

<ul>
<li>Task.java</li>
</ul>

<pre><code class="java">/**
 * This class implements a Task that uses the Lock
 *
 */
public class Task implements Runnable {

    /**
     * Lock used by the task
     */
    private MyLock lock;

    /**
     * Name of the task
     */
    private String name;

    /**
     * Constructor of the class
     * @param name Name of the task
     * @param lock Lock used by the task
     */
    public Task(String name, MyLock lock){
        this.lock=lock;
        this.name=name;
    }

    /**
     * Main method of the task. It gets the lock, sleep the thread for two seconds
     * and then release the lock.
     */
    @Override
    public void run() {
        lock.lock();
        System.out.printf("Task: %s: Take the lock\n",name);
        try {
            TimeUnit.SECONDS.sleep(2);
            System.out.printf("Task: %s: Free the lock\n",name);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}</code></pre>

<ul>
<li>输出结果: 继承<code>AbstractQueuedSynchronizer</code> 和<code>Lock</code>类,来自定义Lock</li>
</ul>

<h2>Implementing a transfer Queue based on priorities</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example.
 *
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) throws Exception{

        /*
         * Create a Prioriy Transfer Queue
         */
        MyPriorityTransferQueue&lt;Event&gt; buffer=new MyPriorityTransferQueue&lt;&gt;();

        /*
         * Create a Producer object
         */
        Producer producer=new Producer(buffer);

        /*
         * Launch 10 producers
         */
        Thread producerThreads[]=new Thread[10];
        for (int i=0; i&lt;producerThreads.length; i++) {
            producerThreads[i]=new Thread(producer);
            producerThreads[i].start();
        }

        /*
         * Create and launch the consumer
         */
        Consumer consumer=new Consumer(buffer);
        Thread consumerThread=new Thread(consumer);
        consumerThread.start();

        /*
         * Write in the console the actual consumer count
         */
        System.out.printf("Main: Buffer: Consumer count: %d\n",buffer.getWaitingConsumerCount());

        /*
         * Transfer an event to the consumer
         */
        Event myEvent=new Event("Core Event",0);
        buffer.transfer(myEvent);
        System.out.printf("Main: My Event has ben transfered.\n");

        /*
         * Wait for the finalization of the producers
         */
        for (int i=0; i&lt;producerThreads.length; i++) {
            producerThreads[i].join();
        }

        /*
         * Sleep the thread for one second
         */
        TimeUnit.SECONDS.sleep(1);

        /*
         * Write the actual consumer count
         */
        System.out.printf("Main: Buffer: Consumer count: %d\n",buffer.getWaitingConsumerCount());

        /*
         * Transfer another event
         */
        myEvent=new Event("Core Event 2",0);
        buffer.transfer(myEvent);

        /*
         * Wait for the finalization of the consumer
         */
        consumerThread.join();

        /*
         * Write a message indicating the end of the program
         */
        System.out.printf("Main: End of the program\n");
    }

}</code></pre>

<ul>
<li>Consumer.java</li>
</ul>

<pre><code class="java">/**
 *  This class implements the Consumer of the events. There is only
 * one consumer in the example that consumes 1002 events 
 *
 */
public class Consumer implements Runnable {

    /**
     * Buffer from which the consumer takes the events
     */
    private MyPriorityTransferQueue&lt;Event&gt; buffer;

    /**
     * Constructor of the class. Initializes its attributes
     * @param buffer Buffer from which the consumer takes the events
     */
    public Consumer(MyPriorityTransferQueue&lt;Event&gt; buffer) {
        this.buffer=buffer;
    }

    /**
     * Main method of the consumer. It takes 1002 events from the buffer
     */
    @Override
    public void run() {
        for (int i=0; i&lt;1002; i++) {
            try {
                Event value=buffer.take();
                System.out.printf("Consumer: %s: %d\n",value.getThread(),value.getPriority());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

}</code></pre>

<ul>
<li>Event.java</li>
</ul>

<pre><code class="java">/**
 * This class stores the attributes of an event. Its thread
 * and is priority. Implements the comparable interface to
 * help the priority queue to decide which event has more priority 
 *
 */
public class Event implements Comparable&lt;Event&gt; {

    /**
     * Number of the thread that generates the event
     */
    private String thread;
    /**
     * Priority of the thread
     */
    private int priority;

    /**
     * Constructor of the thread. It initializes its attributes
     * @param thread Number of the thread that generates the event
     * @param priority Priority of the event
     */
    public Event(String thread, int priority){
        this.thread=thread;
        this.priority=priority;
    }

    /**
     * Method that returns the number of the thread that generates the
     * event
     * @return The number of the thread that generates the event
     */
    public String getThread() {
        return thread;
    }

    /**
     * Method that returns the priority of the event
     * @return The priority of the event
     */
    public int getPriority() {
        return priority;
    }

    /**
     * Method that compares two events and decide which has more priority
     */
    @Override
    public int compareTo(Event e) {
        if (this.priority&gt;e.getPriority()) {
            return -1;
        } else if (this.priority&lt;e.getPriority()) {
            return 1; 
        } else {
            return 0;
        }
    }
}</code></pre>

<ul>
<li>MyPriorityTransferQueue.java</li>
</ul>

<pre><code class="java">/**
 * This class implements a priority based transfer queue. It extends the
 * PriorityBlockingQueue class and implements the TransferQueue interface
 *
 * @param &lt;E&gt; Class of the elements to be stored in the queue
 */
public class MyPriorityTransferQueue&lt;E&gt; extends PriorityBlockingQueue&lt;E&gt; implements
        TransferQueue&lt;E&gt; {

    /**
     * Serial Version of the class
     */
    private static final long serialVersionUID = 1L;

    /**
     * Number of consumers waiting
     */
    private AtomicInteger counter;

    /**
     * Blocking queue to store the transfered elements
     */
    private LinkedBlockingQueue&lt;E&gt; transfered;

    /**
     * Lock to control the acces to the operations
     */
    private ReentrantLock lock;

    /**
     * Constructor of the class
     */
    public MyPriorityTransferQueue() {
        counter=new AtomicInteger(0);
        lock=new ReentrantLock();
        transfered=new LinkedBlockingQueue&lt;&gt;();
    }

    /**
     * This method tries to transfer an element to a consumer. If there is
     * a consumer waiting, we puts the element in the queue and return the
     * true value. Else, return the false value.
     */
    @Override
    public boolean tryTransfer(E e) {
        lock.lock();
        boolean value;
        if (counter.get()==0) {
            value=false;
        } else {
            put(e);
            value=true;
        }
        lock.unlock();
        return value;
    }

    /**
     * Transfer an element to the consumer. If there is a consumer waiting,
     * puts the element on the queue and return the true value. Else, puts the
     * value in the transfered queue and returns the false value. In this case, the
     * thread than makes the call will be blocked until a consumer takes the transfered
     * elements
     */
    @Override
    public void transfer(E e) throws InterruptedException {
        lock.lock();
        if (counter.get()!=0) {
            put(e);
            lock.unlock();
        } else {
            transfered.add(e);
            lock.unlock();
            synchronized (e) {
                e.wait();
            }
        }
    }

    /**
     * This method tries to transfer an element to a consumer waiting a maximum period
     * of time. If there is a consumer waiting, puts the element in the queue. Else,
     * puts the element in the queue of transfered elements and wait the specified period of time
     * until that time pass or the thread is interrupted.
     */
    @Override
    public boolean tryTransfer(E e, long timeout, TimeUnit unit)
            throws InterruptedException {
        lock.lock();
        if (counter.get()!=0) {
            put(e);
            lock.unlock();
            return true;
        } else {
            transfered.add(e);
            long newTimeout=TimeUnit.MILLISECONDS.convert(timeout, unit);
            lock.unlock();
            e.wait(newTimeout);
            lock.lock();
            if (transfered.contains(e)) {
                transfered.remove(e);
                lock.unlock();
                return false;
            } else {
                lock.unlock();
                return true;
            }
        }
    }


    /**
     * Method that returns if the queue has waiting consumers
     */
    @Override
    public boolean hasWaitingConsumer() {
        return (counter.get()!=0);
    }

    /**
     * Method that returns the number of waiting consumers
     */
    @Override
    public int getWaitingConsumerCount() {
        return counter.get();
    }

    /**
     * Method that returns the first element of the queue or is blocked if the queue
     * is empty. If there is transfered elements, takes the first transfered element and
     * wake up the thread that is waiting for the transfer of that element. Else, takes the
     * first element of the queue or is blocked until there is one element in the queue.
     */
    @Override
    public E take() throws InterruptedException {
        lock.lock();
        counter.incrementAndGet();
        E value=transfered.poll();
        if (value==null) {
            lock.unlock();
            value=super.take();
            lock.lock();
        } else {
            synchronized (value) {
                value.notify();
            }
        }
        counter.decrementAndGet();
        lock.unlock();
        return value;
    }
}</code></pre>

<ul>
<li>Producer.java</li>
</ul>

<pre><code class="java">/**
 * This class implements the producers of data. It store 100
 * events in the queue with incremental priority
 *
 */
public class Producer implements Runnable {

    /**
     * Buffer used to store the events
     */
    private MyPriorityTransferQueue&lt;Event&gt; buffer;

    /**
     * Constructor of the class. It initializes its parameters
     * @param buffer Buffer to store the events
     */
    public Producer(MyPriorityTransferQueue&lt;Event&gt; buffer) {
        this.buffer=buffer;
    }

    /**
     * Main method of the producer. Store 100 events in the buffer with
     * incremental priority
     */
    @Override
    public void run() {
        for (int i=0; i&lt;100; i++) {
            Event event=new Event(Thread.currentThread().getName(),i);
            buffer.put(event);
        }
    }

}</code></pre>

<ul>
<li>输出结果: 自定义实现了 线程内转换数据</li>
</ul>

<h2>Implementing your own atomic object</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example
 *
 */
public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) throws Exception{
        /*
         * Create a ParkingCounter object
         */
        ParkingCounter counter=new ParkingCounter(5);

        /*
         * Create and launch two sensors
         */
        Sensor1 sensor1=new Sensor1(counter);
        Sensor2 sensor2=new Sensor2(counter);

        Thread thread1=new Thread(sensor1);
        Thread thread2=new Thread(sensor2);

        thread1.start();
        thread2.start();

        /*
         * Wait for the finalization of the threads
         */
        thread1.join();
        thread2.join();

        /*
         * Write in the console the number of cars in the parking
         */
        System.out.printf("Main: Number of cars: %d\n",counter.get());

        /*
         * Writ a message indicating the end of the program
         */
        System.out.printf("Main: End of the program.\n");
    }
}</code></pre>

<ul>
<li>ParkingCounter.java</li>
</ul>

<pre><code class="java">/**
 * This class implements an atomic object extending the
 * AtomicInteger class and  providing two additional operations
 *  
 */
public class ParkingCounter extends AtomicInteger {

    /**
     * Serial Version UID of the class 
     */
    private static final long serialVersionUID = 1L;

    /**
     * Max number accepted by this counter
     */
    private int maxNumber;

    /**
     * Constructor of the class
     * @param maxNumber Max number accepter by this counter
     */
    public ParkingCounter(int maxNumber){
        set(0);
        this.maxNumber=maxNumber;
    }

    /**
     * Method that increments the internal counter if it has
     * a value less than the maximum. Is implemented to be and
     * atomic operation
     * @return True if the car can enter in the parking, false if not.
     */
    public boolean carIn() {
        for (;;) {
            int value=get();
            if (value==maxNumber) {
                System.out.printf("ParkingCounter: The parking is full.\n");
                return false;
            } else {
                int newValue=value+1;
                boolean changed=compareAndSet(value,newValue);
                if (changed) {
                    System.out.printf("ParkingCounter: A car has entered.\n");
                    return true;
                }
            }
        }
    }

    /**
     * Method that decrements the internal counter if it has
     * a value bigger than 0. Is implemented to be and
     * atomic operation
     * @return True if the car leave the parking, false if there are 0 cars 
     * in the parking
     */
    public boolean carOut() {
        for (;;) {
            int value=get();
            if (value==0) {
                System.out.printf("ParkingCounter: The parking is empty.\n");
                return false;
            } else {
                int newValue=value-1;
                boolean changed=compareAndSet(value,newValue);
                if (changed) {
                    System.out.printf("ParkingCounter: A car has gone out.\n");
                    return true;
                }
            }
        }
    }

}</code></pre>

<ul>
<li>Sensor1.java</li>
</ul>

<pre><code class="java">/**
 * Class that simulates a sensor in the doors of the parking
 *
 */
public class Sensor1 implements Runnable {

    /**
     * Counter of cars in the parking
     */
    private ParkingCounter counter;

    /**
     * Constructor of the class. It initializes its attributes
     * @param counter Counter of cars in the parking
     */
    public Sensor1(ParkingCounter counter) {
        this.counter=counter;
    }


    /**
     * Main method of the sensor. Simulates the traffic in the door of the parking
     */
    @Override
    public void run() {
        counter.carIn();
        counter.carIn();
        counter.carIn();
        counter.carIn();
        counter.carOut();
        counter.carOut();
        counter.carOut();
        counter.carIn();
        counter.carIn();
        counter.carIn();
    }

}</code></pre>

<ul>
<li>Sensor2.java</li>
</ul>

<pre><code class="java">/**
 * Class that simulates a sensor in the doors of the parking
 *
 */
public class Sensor2 implements Runnable {

    /**
     * Counter of cars in the parking
     */
    private ParkingCounter counter;

    /**
     * Constructor of the class. It initializes its attributes
     * @param counter Counter of cars in the parking
     */
    public Sensor2(ParkingCounter counter) {
        this.counter=counter;
    }

    /**
     * Main method of the sensor. Simulates the traffic in the door of the parking
     */
    @Override
    public void run() {
        counter.carIn();
        counter.carOut();
        counter.carOut();
        counter.carIn();
        counter.carIn();
        counter.carIn();
        counter.carIn();
        counter.carIn();
        counter.carIn();
    }

}</code></pre>

<ul>
<li>输出结果:  继承<code>AtomicInteger</code>类,来实现停车场功能,实现的非常优雅哦!</li>
</ul>
<script type='text/javascript'>
$(document).ready(function(){
  if($('code').length>0){
    $('code').parent().addClass('prettyprint linenums');
    prettyPrint();
};
});
</script>
</body>
</html>