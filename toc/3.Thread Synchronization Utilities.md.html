<!doctype html public '-//W3C//DTD HTML 4.0 Transitional //EN'>
<html>
<head>
<title>3.Thread Synchronization Utilities</title>
<meta charset='UTF-8' />
<meta name='generator' content='EverEdit' />
<link href='D:\EverEdit\mode\markdown\default.css' rel='stylesheet'></link>
<link href='D:\EverEdit\mode\markdown\prettify.css' rel='stylesheet'></link>
<script type='text/javascript' src='D:\EverEdit\mode\markdown\prettify.js'></script>
<script type='text/javascript' src='D:\EverEdit\mode\markdown\jquery-1.10.2.min.js'></script>
<script type='text/javascript' src='D:\EverEdit\mode\markdown\toc.js'></script>
</head>
<body>
<div id='generated-toc'></div>
<h2>更高层的机制</h2>

<ul>
<li><code>Semaphores</code>: A semaphore is a counter that controls the access to one or
more shared resources. This mechanism is one of the basic tools of concurrent
programming and is provided by most of the programming languages.</li>
<li><code>CountDownLatch</code>: The  CountDownLatch class is a mechanism provided by the Java
language that allows a thread to wait for the finalization of multiple operations.</li>
<li><code>CyclicBarrier</code>: The  CyclicBarrier class is another mechanism provided by the
Java language that allows the synchronization of multiple threads in a common point.</li>
<li><code>Phaser</code>: The  Phaser class is another mechanism provided by the Java language that
controls the execution of concurrent tasks divided in phases. All the threads must
finish one phase before they can continue with the next one. This is a new feature of
the Java 7 API.</li>
<li><code>Exchanger</code>: The  Exchanger class is another mechanism provided by the Java
language that provides a point of data interchange between two threads.</li>
</ul>

<p>Semaphores are a generic synchronization mechanism that you can use to protect any critical
section in any problem. The other mechanisms are thought to be used in applications with
specific features as it was described previously. Be sure to select the appropriate mechanism
according to the characteristics of your application.</p>

<h2>Controlling concurrent access to a resource</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example.
 *
 */
public class Main {

    /**
     * Main method of the class. Run ten jobs in parallel that
     * send documents to the print queue at the same time.
     */
    public static void main (String args[]){

        // Creates the print queue
        PrintQueue printQueue=new PrintQueue();

        // Creates ten Threads
        Thread thread[]=new Thread[10];
        for (int i=0; i&lt;10; i++){
            thread[i]=new Thread(new Job(printQueue),"Thread "+i);
        }

        // Starts the Threads
        for (int i=0; i&lt;10; i++){
            thread[i].start();
        }
    }

}</code></pre>

<ul>
<li>Job.java</li>
</ul>

<pre><code class="java">/**
 * This class simulates a job that send a document to print.
 *
 */
public class Job implements Runnable {

    /**
     * Queue to print the documents
     */
    private PrintQueue printQueue;

    /**
     * Constructor of the class. Initializes the queue
     * @param printQueue
     */
    public Job(PrintQueue printQueue){
        this.printQueue=printQueue;
    }

    /**
     * Core method of the Job. Sends the document to the print queue and waits
     *  for its finalization
     */
    @Override
    public void run() {
        System.out.printf("%s: Going to print a job\n",Thread.currentThread().getName());
        printQueue.printJob(new Object());
        System.out.printf("%s: The document has been printed\n",Thread.currentThread().getName());      
    }
}</code></pre>

<ul>
<li>PrintQueue.java</li>
</ul>

<pre><code class="java">/**
 * This class implements the PrintQueue using a Semaphore to control the
 * access to it. 
 *
 */
public class PrintQueue {

    /**
     * Semaphore to control the access to the queue
     */
    private final Semaphore semaphore;

    /**
     * Constructor of the class. Initializes the semaphore
     */
    public PrintQueue(){
        semaphore=new Semaphore(1);
    }

    /**
     * Method that simulates printing a document
     * @param document Document to print
     */
    public void printJob (Object document){
        try {
            // Get the access to the semaphore. If other job is printing, this
            // thread sleep until get the access to the semaphore
            semaphore.acquire();

            Long duration=(long)(Math.random()*10);
            System.out.printf("%s: PrintQueue: Printing a Job during %d seconds\n",Thread.currentThread().getName(),duration);
            Thread.sleep(duration);         
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // Free the semaphore. If there are other threads waiting for this semaphore,
            // the JVM selects one of this threads and give it the access.
            semaphore.release();            
        }
    }

}</code></pre>

<ul>
<li><p>输出结果: 同样是打印机,这次使用Semaphors来实现,和ReentrantLock类似,都有公平和非公平模式</p></li>
<li><p>Semaphors的构造参数是1的原因?</p></li>
</ul>

<p>Another important point in this example is the constructor of the  PrintQueue class and
the initialization of the  Semaphore object. You pass the value  1 as the parameter of this
constructor, so you are creating a binary semaphore. The initial value of the internal counter
is  1 , so you will protect the access to one shared resource, in this case, the print queue.
When you start the 10 threads, the first one acquires the semaphore and gets the access to
the critical section. The rest are blocked by the semaphore until the thread that has acquired
it, releases it. When this occurs, the semaphore selects one of the waiting threads and gives it
the access to the critical section. All the jobs print their documents, but one by one.</p>

<h2>Controlling concurrent access to multiple copies of a resource</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example.
 *
 */
public class Main {

    /**
     * Main method of the class. Run ten jobs in parallel that
     * send documents to the print queue at the same time.
     */
    public static void main (String args[]){

        // Creates the print queue
        PrintQueue printQueue=new PrintQueue();

        // Creates ten Threads
        Thread thread[]=new Thread[12];
        for (int i=0; i&lt;12; i++){
            thread[i]=new Thread(new Job(printQueue),"Thread "+i);
        }

        // Starts the Threads
        for (int i=0; i&lt;12; i++){
            thread[i].start();
        }
    }

}</code></pre>

<ul>
<li>Job.java</li>
</ul>

<pre><code class="java">/**
 * This class simulates a job that send a document to print.
 *
 */
public class Job implements Runnable {

    /**
     * Queue to print the documents
     */
    private PrintQueue printQueue;

    /**
     * Constructor of the class. Initializes the queue
     * @param printQueue
     */
    public Job(PrintQueue printQueue){
        this.printQueue=printQueue;
    }

    /**
     * Core method of the Job. Sends the document to the print queue and waits
     *  for its finalization
     */
    @Override
    public void run() {
        System.out.printf("%s: Going to print a job\n",Thread.currentThread().getName());
        printQueue.printJob(new Object());
        System.out.printf("%s: The document has been printed\n",Thread.currentThread().getName());      
    }
}</code></pre>

<ul>
<li>PrintQueue.java</li>
</ul>

<pre><code class="java">/**
 * This class implements a PrintQueue that have access to three printers.
 * 
 * We use a Semaphore to control the access to one of the printers. When
 * a job wants to print, if there is one or more printers free, it has access
 * to one of the free printers. If not, it sleeps until one of the printers
 * is free.
 *
 */
public class PrintQueue {

    /**
     * Semaphore to control the access to the printers
     */
    private Semaphore semaphore;

    /**
     * Array to control what printer is free
     */
    private boolean freePrinters[];

    /**
     * Lock to control the access to the freePrinters array
     */
    private Lock lockPrinters;

    /**
     * Constructor of the class. It initializes the three objects
     */
    public PrintQueue(){
        semaphore=new Semaphore(3);
        freePrinters=new boolean[3];
        for (int i=0; i&lt;3; i++){
            freePrinters[i]=true;
        }
        lockPrinters=new ReentrantLock();
    }

    public void printJob (Object document){
        try {
            // Get access to the semaphore. If there is one or more printers free,
            // it will get the access to one of the printers
            semaphore.acquire();

            // Get the number of the free printer
            int assignedPrinter=getPrinter();

            Long duration=(long)(Math.random()*10);
            System.out.printf("%s: PrintQueue: Printing a Job in Printer %d during %d seconds\n",Thread.currentThread().getName(),assignedPrinter,duration);
            TimeUnit.SECONDS.sleep(duration);

            // Free the printer
            freePrinters[assignedPrinter]=true;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // Free the semaphore
            semaphore.release();            
        }
    }

    private int getPrinter() {
        int ret=-1;

        try {
            // Get the access to the array
            lockPrinters.lock();
            // Look for the first free printer
            for (int i=0; i&lt;freePrinters.length; i++) {
                if (freePrinters[i]){
                    ret=i;
                    freePrinters[i]=false;
                    break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // Free the access to the array
            lockPrinters.unlock();
        }
        return ret;
    }

}</code></pre>

<ul>
<li><p>输出结果: 多台打印机打印多个文件的情况怎么办? 这里用Semaphore + ReentrantLock 来实现</p>

<p>But semaphores can also be used when
you need to protect various copies of a resource, or when you have a critical section that can
be executed by more than one thread at the same time.</p></li>
</ul>

<h2>Waiting for multiple concurrent events</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example. Create, initialize and execute all the objects
 * necessaries for the example
 *
 */
public class Main {

    /**
     * Main method of the example
     * @param args
     */
    public static void main(String[] args) {

        // Creates a VideoConference with 10 participants.
        Videoconference conference=new Videoconference(10);
        // Creates a thread to run the VideoConference and start it.
        Thread threadConference=new Thread(conference);
        threadConference.start();

        // Creates ten participants, a thread for each one and starts them
        for (int i=0; i&lt;10; i++){
            Participant p=new Participant(conference, "Participant "+i);
            Thread t=new Thread(p);
            t.start();
        }

    }

}</code></pre>

<ul>
<li>Participant.java</li>
</ul>

<pre><code class="java">/**
 * This class implements a participant in the VideoConference
 *
 */
public class Participant implements Runnable {

    /**
     * VideoConference in which this participant will take part off
     */
    private Videoconference conference;

    /**
     * Name of the participant. For log purposes only
     */
    private String name;

    /**
     * Constructor of the class. Initialize its attributes
     * @param conference VideoConference in which is going to take part off
     * @param name Name of the participant
     */
    public Participant(Videoconference conference, String name) {
        this.conference=conference;
        this.name=name;
    }

    /**
     * Core method of the participant. Waits a random time and joins the VideoConference 
     */
    @Override
    public void run() {
        Long duration=(long)(Math.random()*10);
        try {
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }   
        conference.arrive(name);

    }
}</code></pre>

<ul>
<li>Videoconference.java</li>
</ul>

<pre><code class="java">/**
 * This class implements the controller of the Videoconference
 * 
 * It uses a CountDownLatch to control the arrival of all the 
 * participants in the conference.
 *
 */
public class Videoconference implements Runnable{

    /**
     * This class uses a CountDownLatch to control the arrivel of all
     * the participants
     */
    private final CountDownLatch controller;

    /**
     * Constructor of the class. Initializes the CountDownLatch
     * @param number The number of participants in the videoconference
     */
    public Videoconference(int number) {
        controller=new CountDownLatch(number);
    }

    /**
     * This method is called by every participant when he incorporates to the VideoConference
     * @param participant
     */
    public void arrive(String name){
        System.out.printf("%s has arrived.\n",name);
        // This method uses the countDown method to decrement the internal counter of the
        // CountDownLatch
        controller.countDown();
        System.out.printf("VideoConference: Waiting for %d participants.\n",controller.getCount());
    }

    /**
     * This is the main method of the Controller of the VideoConference. It waits for all
     * the participants and the, starts the conference
     */
    @Override
    public void run() {
        System.out.printf("VideoConference: Initialization: %d participants.\n",controller.getCount());
        try {
            // Wait for all the participants
            controller.await();
            // Starts the conference
            System.out.printf("VideoConference: All the participants have come\n");
            System.out.printf("VideoConference: Let's start...\n");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


}</code></pre>

<ul>
<li><p>输出结果: 模拟视频会议中,有10个人要参加,必须等到10个人都来了,视频会议才会开始,用到 CountDownLatch</p></li>
<li><p>CountDownLatch具体用法</p></li>
</ul>

<p>The Java concurrency API provides a class that allows one or more threads to wait until a
set of operations are made. It's the  CountDownLatch class. This class is initialized with an
integer number, which is the number of operations the threads are going to wait for. When
a thread wants to wait for the execution of these operations, it uses the  await() method.
This method puts the thread to sleep until the operations are completed. When one of these
operations finishes, it uses the  countDown() method to decrement the internal counter of the  CountDownLatch class. When the counter arrives to  0 , the class wakes up all the
threads that were sleeping in the  await() method.</p>

<p>The  CountDownLatch class has three basic elements:</p>

<ul>
<li>The initialization value that determines how many events the  CountDownLatch class waits for</li>
<li>The  await() method, called by the threads that wait for the finalization of all the events</li>
<li>The  countDown() method, called by the events when they finish their execution</li>
</ul>

<p>When you create a  CountDownLatch object, the object uses the constructor's parameter
to initialize an internal counter. Every time a thread calls the  countDown() method, the
CountDownLatch object decrements the internal counter in one unit. When the internal
counter arrives to  0 , the  CountDownLatch object wakes up all the threads that were waiting
in the  await() method.
There's no way to re-initialize the internal counter of the  CountDownLatch object or to modify
its value. Once the counter is initialized, the only method you can use to modify its value is
the  countDown() method explained earlier. When the counter arrives to  0 , all the calls to the
await() method return immediately and all subsequent calls to the  countDown() method
have no effect.
There are some differences with respect to other synchronization methods, which are
as follows:</p>

<ul>
<li>The  CountDownLatch mechanism is not used to protect a shared resource or a critical section. It is used to synchronize one or more threads with the execution of various tasks.</li>
<li>It only admits one use. As we explained earlier, once the counter of CountDownLatch arrives at  0 , all the calls to its methods have no effect. You have to create a new object if you want to do the same synchronization again.</li>
</ul>

<h2>Synchronizing tasks in a common point</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example
 *
 */
public class Main {

    /**
     * Main method of the example
     * @param args
     */
    public static void main(String[] args) {

        /*
         * Initializes the bi-dimensional array of data
         *      10000 rows
         *      1000 numbers in each row
         *      Looking for number 5
         */
        final int ROWS=10000;
        final int NUMBERS=1000;
        final int SEARCH=5; 
        final int PARTICIPANTS=5;
        final int LINES_PARTICIPANT=2000;
        MatrixMock mock=new MatrixMock(ROWS, NUMBERS,SEARCH);

        // Initializes the object for the results
        Results results=new Results(ROWS);

        // Creates an Grouper object
        Grouper grouper=new Grouper(results);

        // Creates the CyclicBarrier object. It has 5 participants and, when
        // they finish, the CyclicBarrier will execute the grouper object
        CyclicBarrier barrier=new CyclicBarrier(PARTICIPANTS,grouper);

        // Creates, initializes and starts 5 Searcher objects
        Searcher searchers[]=new Searcher[PARTICIPANTS];
        for (int i=0; i&lt;PARTICIPANTS; i++){
            searchers[i]=new Searcher(i*LINES_PARTICIPANT, (i*LINES_PARTICIPANT)+LINES_PARTICIPANT, mock, results, 5,barrier);
            Thread thread=new Thread(searchers[i]);
            thread.start();
        }
        System.out.printf("Main: The main thread has finished.\n");
    }

}</code></pre>

<ul>
<li>Grouper.java</li>
</ul>

<pre><code class="java">/**
 * Group the results of each Searcher. Sum the values stored in the Results object 
 * An object of this class is executed automatically by the CyclicBarrier when
 * all the Searchers finish its job
 */
public class Grouper implements Runnable {

    /**
     * Results object with the occurrences of the number in each row
     */
    private Results results;

    /**
     * Constructor of the class. Initializes its attributes
     * @param results Results object with the ocurrences of the number in each row
     */
    public Grouper(Results results){
        this.results=results;
    }

    /**
     * Main method of the Grouper. Sum the values stored in the Results object 
     */
    @Override
    public void run() {
        int finalResult=0;
        System.out.printf("Grouper: Processing results...\n");
        int data[]=results.getData();
        for (int number:data){
            finalResult+=number;
        }
        System.out.printf("Grouper: Total result: %d.\n",finalResult);
    }

}</code></pre>

<ul>
<li>Searcher.java</li>
</ul>

<pre><code class="java">/**
 * Class that search for a number in a set of rows of the bi-dimensional array
 *
 */
public class Searcher implements Runnable {

    /**
     * First row where look for
     */
    private int firstRow;

    /**
     * Last row where look for
     */
    private int lastRow;

    /**
     * Bi-dimensional array with the numbers
     */
    private MatrixMock mock;

    /**
     * Array to store the results
     */
    private Results results;

    /**
     * Number to look for
     */
    private int number;

    /**
     * CyclicBarrier to control the execution
     */
    private final CyclicBarrier barrier;

    /**
     * Constructor of the class. Initializes its attributes
     * @param firstRow First row where look for
     * @param lastRow Last row where fook for
     * @param mock Object with the array of numbers
     * @param results Array to store the results
     * @param number Number to look for
     * @param barrier CyclicBarrier to control the execution
     */
    public Searcher(int firstRow, int lastRow, MatrixMock mock, Results results, int number, CyclicBarrier barrier){
        this.firstRow=firstRow;
        this.lastRow=lastRow;
        this.mock=mock;
        this.results=results;
        this.number=number;
        this.barrier=barrier;
    }

    /**
     * Main method of the searcher. Look for the number in a subset of rows. For each row, saves the
     * number of occurrences of the number in the array of results
     */
    @Override
    public void run() {
        int counter;
        System.out.printf("%s: Processing lines from %d to %d.\n",Thread.currentThread().getName(),firstRow,lastRow);
        for (int i=firstRow; i&lt;lastRow; i++){
            int row[]=mock.getRow(i);
            counter=0;
            for (int j=0; j&lt;row.length; j++){
                if (row[j]==number){
                    counter++;
                }
            }
            results.setData(i, counter);
        }
        System.out.printf("%s: Lines processed.\n",Thread.currentThread().getName());       
        try {
            barrier.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }

}</code></pre>

<ul>
<li>MatrixMock.java</li>
</ul>

<pre><code class="java">/**
 * This class generates a random matrix of integer numbers between 1 and 10
 *
 */
public class MatrixMock {

    /**
     * Bi-dimensional array with the random numbers
     */
    private int data[][];

    /**
     * Constructor of the class. Generates the bi-dimensional array of numbers.
     * While generates the array, it counts the times that appears the number we are going
     * to look for so we can check that the CiclycBarrier class does a good job
     * @param size Number of rows of the array
     * @param length Number of columns of the array
     * @param number Number we are going to look for
     */
    public MatrixMock(int size, int length, int number){

        int counter=0;
        data=new int[size][length];
        Random random=new Random();
        for (int i=0; i&lt;size; i++) {
            for (int j=0; j&lt;length; j++){
                data[i][j]=random.nextInt(10);
                if (data[i][j]==number){
                    counter++;
                }
            }
        }
        System.out.printf("Mock: There are %d ocurrences of number in generated data.\n",counter,number);
    }

    /**
     * This methods returns a row of the bi-dimensional array
     * @param row the number of the row to return
     * @return the selected row
     */
    public int[] getRow(int row){
        if ((row&gt;=0)&amp;&amp;(row&lt;data.length)){
            return data[row];
        }
        return null;
    }

}</code></pre>

<ul>
<li>Results.java</li>
</ul>

<pre><code class="java">
/**
 * This class is used to store the number of occurrences of the number
 * we are looking for in each row of the bi-dimensional array
 *
 */
public class Results {

    /**
     * Array to store the number of occurrences of the number in each row of the array
     */
    private int data[];

    /**
     * Constructor of the class. Initializes its attributes
     * @param size Size of the array to store the results
     */
    public Results(int size){
        data=new int[size];
    }

    /**
     * Sets the value of one position in the array of results
     * @param position Position in the array
     * @param value Value to set in that position
     */
    public void  setData(int position, int value){
        data[position]=value;
    }

    /**
     * Returns the array of results
     * @return the array of results
     */
    public int[] getData(){
        return data;
    }
}</code></pre>

<ul>
<li>输出结果: 分配5个任务,5个线程分别去做,必须全部完成以后,才开始统计结果</li>
</ul>

<p>The  CyclicBarrier class is initialized with an integer number, which is the number of threads
that will be synchronized in a determined point. When one of those threads arrives to the
determined point, it calls the  await() method to wait for the other threads. When the thread
calls that method, the  CyclicBarrier class blocks the thread that is sleeping until the other
threads arrive. When the last thread calls the  await() method of the  CyclicBarrier class,
it wakes up all the threads that were waiting and continues with its job.</p>

<p>One interesting advantage of the  CyclicBarrier class is that you can pass an additional
Runnable object as an initialization parameter, and the  CyclicBarrier class executes this
object as a thread when all the threads have arrived to the common point. This characteristic
makes this class adequate for the parallelization of tasks using the divide and conquer
programming technique.</p>

<ul>
<li><p>和CountDownLatch的区别(比CountDownLatch多了配置,可以在参数里面配置Runnable,可以应对更加复杂的情况)</p>

<ul><li><code>Resetting a CyclicBarrier object</code>
The  CyclicBarrier class has some points in common with the  CountDownLatch
class, but they also have some differences. One of the most important differences is that a
CyclicBarrier object can be reset to its initial state, assigning to its internal counter the
value with which it was initialized.
This reset operation can be done using the  reset() method of the  CyclicBarrier
class. When this occurs, all the threads that were waiting in the  await() method receive
a  BrokenBarrierException exception. This exception was processed in the example
presented in this recipe by printing the stack trace, but in a more complex application, it could
perform some other operation, such as restarting their execution or recovering their operation
at the point it was interrupted.</li>
<li><code>Broken CyclicBarrier objects</code>
A  CyclicBarrier object can be in a special state denoted by broken. When there are
various threads waiting in the  await() method and one of them is interrupted, this thread
receives an  InterruptedException exception, but the other threads that were waiting
receive a  BrokenBarrierException exception and  CyclicBarrier is placed in the
broken state.</li></ul></li>
</ul>

<h2>Running concurrent phased tasks</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example
 *
 */
public class Main {

    /**
     * Main method of the example
     * @param args
     */
    public static void main(String[] args) {

        // Creates a Phaser with three participants
        Phaser phaser=new Phaser(3);

        // Creates 3 FileSearch objects. Each of them search in different directory
        FileSearch system=new FileSearch("C:\\Windows", "log", phaser);
        FileSearch apps=new FileSearch("C:\\Program Files","log",phaser);
        FileSearch documents=new FileSearch("C:\\Documents And Settings","log",phaser);

        // Creates a thread to run the system FileSearch and starts it
        Thread systemThread=new Thread(system,"System");
        systemThread.start();

        // Creates a thread to run the apps FileSearch and starts it
        Thread appsThread=new Thread(apps,"Apps");
        appsThread.start();

        // Creates a thread to run the documents  FileSearch and starts it
        Thread documentsThread=new Thread(documents,"Documents");
        documentsThread.start();
        try {
            systemThread.join();
            appsThread.join();
            documentsThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.printf("Terminated: %s\n",phaser.isTerminated());

    }

}</code></pre>

<ul>
<li>FileSearch.java</li>
</ul>

<pre><code class="java">/**
 * This class search for files with an extension in a directory
 */
public class FileSearch implements Runnable {

    /**
     * Initial path for the search
     */
    private String initPath;

    /**
     * Extension of the file we are searching for
     */
    private String end;

    /**
     * List that stores the full path of the files that have the extension we are searching for
     */
    private List&lt;String&gt; results;

    /**
     * Phaser to control the execution of the FileSearch objects. Their execution will be divided
     * in three phases
     *  1st: Look in the folder and its subfolders for the files with the extension
     *  2nd: Filter the results. We only want the files modified today
     *  3rd: Print the results
     */ 
    private Phaser phaser;


    /**
     * Constructor of the class. Initializes its attributes
     * @param initPath Initial path for the search
     * @param end Extension of the files we are searching for
     * @param phaser Phaser object to control the execution
     */
    public FileSearch(String initPath, String end, Phaser phaser) {
        this.initPath = initPath;
        this.end = end;
        this.phaser=phaser;
        results=new ArrayList&lt;&gt;();
    }

    /**
     * Main method of the class. See the comments inside to a better description of it
     */
    @Override
    public void run() {

        // Waits for the creation of all the FileSearch objects
        phaser.arriveAndAwaitAdvance();

        System.out.printf("%s: Starting.\n",Thread.currentThread().getName());

        // 1st Phase: Look for the files
        File file = new File(initPath);
        if (file.isDirectory()) {
            directoryProcess(file);
        }

        // If no results, deregister in the phaser and ends
        if (!checkResults()){
            return;
        }

        // 2nd Phase: Filter the results
        filterResults();

        // If no results after the filter, deregister in the phaser and ends
        if (!checkResults()){
            return;
        }

        // 3rd Phase: Show info
        showInfo();
        phaser.arriveAndDeregister();
        System.out.printf("%s: Work completed.\n",Thread.currentThread().getName());

    }

    /**
     * This method prints the final results of the search
     */
    private void showInfo() {
        for (int i=0; i&lt;results.size(); i++){
            File file=new File(results.get(i));
            System.out.printf("%s: %s\n",Thread.currentThread().getName(),file.getAbsolutePath());
        }
        // Waits for the end of all the FileSearch threads that are registered in the phaser
        phaser.arriveAndAwaitAdvance();
    }

    /**
     * This method checks if there are results after the execution of a phase. If there aren't
     * results, deregister the thread of the phaser.
     * @return true if there are results, false if not
     */
    private boolean checkResults() {
        if (results.isEmpty()) {
            System.out.printf("%s: Phase %d: 0 results.\n",Thread.currentThread().getName(),phaser.getPhase());
            System.out.printf("%s: Phase %d: End.\n",Thread.currentThread().getName(),phaser.getPhase());
            // No results. Phase is completed but no more work to do. Deregister for the phaser
            phaser.arriveAndDeregister();
            return false;
        } else {
            // There are results. Phase is completed. Wait to continue with the next phase
            System.out.printf("%s: Phase %d: %d results.\n",Thread.currentThread().getName(),phaser.getPhase(),results.size());
            phaser.arriveAndAwaitAdvance();
            return true;
        }       
    }

    /**
     * Method that filter the results to delete the files modified more than a day before now
     */
    private void filterResults() {
        List&lt;String&gt; newResults=new ArrayList&lt;&gt;();
        long actualDate=new Date().getTime();
        for (int i=0; i&lt;results.size(); i++){
            File file=new File(results.get(i));
            long fileDate=file.lastModified();

            if (actualDate-fileDate&lt;TimeUnit.MILLISECONDS.convert(1,TimeUnit.DAYS)){
                newResults.add(results.get(i));
            }
        }
        results=newResults;
    }

    /**
     * Method that process a directory
     * 
     * @param file
     *            : Directory to process
     */
    private void directoryProcess(File file) {

        // Get the content of the directory
        File list[] = file.listFiles();
        if (list != null) {
            for (int i = 0; i &lt; list.length; i++) {
                if (list[i].isDirectory()) {
                    // If is a directory, process it
                    directoryProcess(list[i]);
                } else {
                    // If is a file, process it
                    fileProcess(list[i]);
                }
            }
        }
    }

    /**
     * Method that process a File
     * 
     * @param file
     *            : File to process
     */
    private void fileProcess(File file) {
        if (file.getName().endsWith(end)) {
            results.add(file.getAbsolutePath());
        }
    }

}</code></pre>

<ul>
<li><p>输出结果: 这个例子稍微复杂了些,是分阶段性的查看的,Apps&#8211;>System&#8211;>Documents,依次进行</p></li>
<li><p>Phaser的使用</p></li>
</ul>

<p>The first instruction in the  run() method of this  FileSearch object is a call to the
arriveAndAwaitAdvance() method of the  Phaser object. As we mentioned earlier, the
Phaser knows the number of threads that we want to synchronize. When a thread calls this
method,  Phaser decreases the number of threads that have to finalize the actual phase and
puts this thread to sleep until all the remaining threads finish this phase. Calling this method
at the beginning of the  run() method makes none of the  FileSearch threads begin their
job until all the threads have been created.</p>

<p>At the end of phase one and phase two, we check if the phase has generated results and the
list with the results has elements, or otherwise the phase hasn't generated results and the list
is empty. In the first case, the  checkResults() method calls  arriveAndAwaitAdvance()
as explained earlier. In the second case, if the list is empty, there's no point in the thread
continuing with its execution, so it returns. But you have to notify the phaser that there will be one less participant. For this, we used  arriveAndDeregister() . This notifies the phaser
that this thread has finished the actual phase, but it won't participate in the future phases, so
the phaser won't have to wait for it to continue.</p>

<p>At the end of the phase three implemented in the  showInfo() method, there is a call to the
arriveAndAwaitAdvance() method of the phaser. With this call, we guarantee that all the
threads finish at the same time. When this method ends its execution, there is a call to the
arriveAndDeregister() method of the phaser. With this call, we deregister the threads
of the phaser as we explained before, so when all the threads finish, the phaser will have zero
participants.</p>

<p>Finally, the  main() method waits for the completion of the three threads and calls the
isTerminated() method of the phaser. When a phaser has zero participants, it enters the
so called termination state and this method returns  true . As we deregister all the threads of
the phaser, it will be in the termination state and this call will print  true to the console</p>

<p>A  Phaser object can be in two states:</p>

<ul>
<li><code>Active</code>:  Phaser enters this state when it accepts the registration of new participants
and its synchronization at the end of each phase. In this state,  Phaser works as it has
been explained in this recipe. This state is not mentioned in the Java concurrency API.</li>
<li><p><code>Termination</code>: By default,  Phaser enters in this state when all the participants in
Phaser have been deregistered, so  Phaser has zero participants. More in detail,
Phaser is in the termination state when the method  onAdvance() returns the
true value. If you override that method, you can change the default behavior. When
Phaser is on this state, the synchronization method  arriveAndAwaitAdvance()
returns immediately without doing any synchronization operation.
A notable feature of the  Phaser class is that you haven't had to control any exception
from the methods related with the phaser. Unlike other synchronization utilities, threads
that are sleeping in a phaser don't respond to interruption events and don't throw an
InterruptedException exception. There is only one exception that is explained in the
There's more section below.</p></li>
<li><p>可以注册Phaser和强制注册Phaser</p></li>
</ul>

<h2>Controlling phase change in concurrent phased tasks</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example 
 *
 */
public class Main {

    /**
     * Main method of the example
     * @param args
     */
    public static void main(String[] args) {

        // Creates the Phaser
        MyPhaser phaser=new MyPhaser();

        // Creates 5 students and register them in the phaser
        Student students[]=new Student[5];
        for (int i=0; i&lt;students.length; i++){
            students[i]=new Student(phaser);
            phaser.register();
        }

        // Create 5 threads for the students and start them
        Thread threads[]=new Thread[students.length];
        for (int i=0; i&lt;students.length; i++) {
            threads[i]=new Thread(students[i],"Student "+i);
            threads[i].start();
        }

        // Wait for the finalization of the threads
        for (int i=0; i&lt;threads.length; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // Check that the Phaser is in the Terminated state
        System.out.printf("Main: The phaser has finished: %s.\n",phaser.isTerminated());

    }

}</code></pre>

<ul>
<li>MyPhaser.java</li>
</ul>

<pre><code class="java">/**
 * Implements a subclass of the Phaser class. Overrides the onAdvance method to control
 * the change of phase 
 *
 */
public class MyPhaser extends Phaser {

    /**
     * This method is called when the last register thread calls one of the advance methods
     * in the actual phase
     * @param phase Actual phase
     * @param registeredParties Number of registered threads
     * @return false to advance the phase, true to finish
     */
    @Override
    protected boolean onAdvance(int phase, int registeredParties) {
        switch (phase) {
        case 0:
            return studentsArrived();
        case 1:
            return finishFirstExercise();
        case 2:
            return finishSecondExercise();
        case 3:
            return finishExam();
        default:
            return true;
        }
    }

    /**
     * This method is called in the change from phase 0 to phase 1
     * @return false to continue with the execution
     */
    private boolean studentsArrived() {
        System.out.printf("Phaser: The exam are going to start. The students are ready.\n");
        System.out.printf("Phaser: We have %d students.\n",getRegisteredParties());
        return false;
    }

    /**
     * This method is called in the change from phase 1 to phase 2
     * @return false to continue with the execution
     */
    private boolean finishFirstExercise() {
        System.out.printf("Phaser: All the students has finished the first exercise.\n");
        System.out.printf("Phaser: It's turn for the second one.\n");
        return false;
    }

    /**
     * This method is called in the change form phase 2 to phase 3
     * @return false to continue with the execution
     */
    private boolean finishSecondExercise() {
        System.out.printf("Phaser: All the students has finished the second exercise.\n");
        System.out.printf("Phaser: It's turn for the third one.\n");
        return false;
    }

    /**
     * This method is called in the change from phase 3 to phase 4
     * @return true. There are no more phases
     */
    private boolean finishExam() {
        System.out.printf("Phaser: All the students has finished the exam.\n");
        System.out.printf("Phaser: Thank you for your time.\n");
        return true;
    }

}</code></pre>

<ul>
<li>Student.java</li>
</ul>

<pre><code class="java">/**
 * This class implements an student in the exam 
 *
 */
public class Student implements Runnable {

    /**
     * Phaser to control the execution
     */
    private Phaser phaser;

    /**
     * Constructor of the class. Initialize its objects
     * @param phaser Phaser to control the execution
     */
    public Student(Phaser phaser) {
        this.phaser=phaser;
    }

    /**
     * Main method of the student. It arrives to the exam and does three exercises. After each
     * exercise, it calls the phaser to wait that all the students finishes the same exercise
     */
    public void run() {
        System.out.printf("%s: Has arrived to do the exam. %s\n",Thread.currentThread().getName(),new Date());
        phaser.arriveAndAwaitAdvance();
        System.out.printf("%s: Is going to do the first exercise. %s\n",Thread.currentThread().getName(),new Date());
        doExercise1();
        System.out.printf("%s: Has done the first exercise. %s\n",Thread.currentThread().getName(),new Date());
        phaser.arriveAndAwaitAdvance();
        System.out.printf("%s: Is going to do the second exercise. %s\n",Thread.currentThread().getName(),new Date());
        doExercise2();
        System.out.printf("%s: Has done the second exercise. %s\n",Thread.currentThread().getName(),new Date());
        phaser.arriveAndAwaitAdvance();
        System.out.printf("%s: Is going to do the third exercise. %s\n",Thread.currentThread().getName(),new Date());
        doExercise3();
        System.out.printf("%s: Has finished the exam. %s\n",Thread.currentThread().getName(),new Date());
        phaser.arriveAndAwaitAdvance();
    }

    /**
     * Does an exercise is to wait a random time 
     */
    private void doExercise1() {
        try {
            Long duration=(long)(Math.random()*10);
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * Does an exercise is wait a random time 
     */
    private void doExercise2() {
        try {
            Long duration=(long)(Math.random()*10);
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * Does an exercise is wait a random time 
     */
    private void doExercise3() {
        try {
            Long duration=(long)(Math.random()*10);
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


}</code></pre>

<ul>
<li>输出结果: 模拟的5个考生考试,分3个阶段考试.必须5个考生完成每个阶段后,才可以继续下一个阶段,直到完成所有的考试,重写了Phaser的onAdvance方法,分为好几个阶段,每个阶段的开始时间,线程都是一样的!</li>
</ul>

<h2>Changing data between concurrent tasks</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example
 *
 */
public class Main {

    /**
     * Main method of the example
     * @param args
     */
    public static void main(String[] args) {

        // Creates two buffers
        List&lt;String&gt; buffer1=new ArrayList&lt;&gt;();
        List&lt;String&gt; buffer2=new ArrayList&lt;&gt;();

        // Creates the exchanger
        Exchanger&lt;List&lt;String&gt;&gt; exchanger=new Exchanger&lt;&gt;();

        // Creates the producer
        Producer producer=new Producer(buffer1, exchanger);
        // Creates the consumer
        Consumer consumer=new Consumer(buffer2, exchanger);

        // Creates and starts the threads
        Thread threadProducer=new Thread(producer);
        Thread threadConsumer=new Thread(consumer);

        threadProducer.start();
        threadConsumer.start();

    }

}</code></pre>

<ul>
<li>Consumer.java</li>
</ul>

<pre><code class="java">/**
 * This class implements the consumer of the example
 *
 */
public class Consumer implements Runnable {

    /**
     * Buffer to save the events produced
     */
    private List&lt;String&gt; buffer;

    /**
     * Exchager to synchronize with the consumer
     */
    private final Exchanger&lt;List&lt;String&gt;&gt; exchanger;

    /**
     * Constructor of the class. Initializes its attributes
     * @param buffer Buffer to save the events produced
     * @param exchanger Exchanger to syncrhonize with the consumer
     */
    public Consumer(List&lt;String&gt; buffer, Exchanger&lt;List&lt;String&gt;&gt; exchanger){
        this.buffer=buffer;
        this.exchanger=exchanger;
    }

    /**
     * Main method of the producer. It consumes all the events produced by the Producer. After
     * processes ten events, it uses the exchanger object to synchronize with 
     * the producer. It sends to the producer an empty buffer and receives a buffer with ten events
     */
    @Override
    public void run() {
        int cycle=1;

        for (int i=0; i&lt;10; i++){
            System.out.printf("Consumer: Cycle %d\n",cycle);

            try {
                // Wait for the produced data and send the empty buffer to the producer
                buffer=exchanger.exchange(buffer);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.printf("Consumer: %d\n",buffer.size());

            for (int j=0; j&lt;10; j++){
                String message=buffer.get(0);
                System.out.printf("Consumer: %s\n",message);
                buffer.remove(0);
            }

            cycle++;
        }

    }

}</code></pre>

<ul>
<li>Producer.java</li>
</ul>

<pre><code class="java">/**
 * This class implements the producer
 *
 */
public class Producer implements Runnable {

    /**
     * Buffer to save the events produced
     */
    private List&lt;String&gt; buffer;

    /**
     * Exchager to synchronize with the consumer
     */
    private final Exchanger&lt;List&lt;String&gt;&gt; exchanger;

    /**
     * Constructor of the class. Initializes its attributes
     * @param buffer Buffer to save the events produced
     * @param exchanger Exchanger to syncrhonize with the consumer
     */
    public Producer (List&lt;String&gt; buffer, Exchanger&lt;List&lt;String&gt;&gt; exchanger){
        this.buffer=buffer;
        this.exchanger=exchanger;
    }

    /**
     * Main method of the producer. It produces 100 events. 10 cicles of 10 events.
     * After produce 10 events, it uses the exchanger object to synchronize with 
     * the consumer. The producer sends to the consumer the buffer with ten events and
     * receives from the consumer an empty buffer
     */
    @Override
    public void run() {
        int cycle=1;

        for (int i=0; i&lt;10; i++){
            System.out.printf("Producer: Cycle %d\n",cycle);

            for (int j=0; j&lt;10; j++){
                String message="Event "+((i*10)+j);
                System.out.printf("Producer: %s\n",message);
                buffer.add(message);
            }

            try {
                /*
                 * Change the data buffer with the consumer
                 */
                buffer=exchanger.exchange(buffer);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.printf("Producer: %d\n",buffer.size());

            cycle++;
        }

    }



}</code></pre>

<ul>
<li>输出结果: 用Exchanger机制来模拟经典的生产者-消费者模式,而且可以两个线程之间交换数据</li>
</ul>

<p>The Java concurrency API provides a synchronization utility that allows the interchange of data
between two concurrent tasks. In more detail, the  Exchanger class allows the definition of
a synchronization point between two threads. When the two threads arrive to this point, they
interchange a data structure so the data structure of the first thread goes to the second one
and the data structure of the second thread goes to the first one.
This class may be very useful in a situation similar to the producer-consumer problem. This
is a classic concurrent problem where you have a common buffer of data, one or more
producers of data, and one or more consumers of data. As the  Exchanger class only
synchronizes two threads, you can use it if you have a producer-consumer problem with one
producer and one consumer</p>

<p>The consumer begins with an empty buffer and calls  Exchanger to synchronize with the
producer. It needs data to consume. The producer begins its execution with an empty buffer.
It creates 10 strings, stores it in the buffer, and uses the exchanger to synchronize with
the consumer.</p>

<p>At this point, both threads (producer and consumer) are in  Exchanger and it changes the
data structures, so when the consumer returns from the  exchange() method, it will have a
buffer with 10 strings. When the producer returns from the  exchange() method, it will have
an empty buffer to fill again. This operation will be repeated 10 times</p>
<script type='text/javascript'>
$(document).ready(function(){
  if($('code').length>0){
    $('code').parent().addClass('prettyprint linenums');
    prettyPrint();
};
});
</script>
</body>
</html>