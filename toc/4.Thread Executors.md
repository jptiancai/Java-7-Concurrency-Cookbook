## 并发编程的缺点

If you have to develop a program that runs a lot of concurrent tasks, this approach has the
following disadvantages:

- You have to implement all the code-related information to the management of the Thread objects (creation, ending, obtaining results).
- You create a  Thread object per task. If you have to execute a big number of tasks, this can affect the throughput of the application.

- You have to control and manage efficiently the resources of the computer.If you create too many threads, you can saturate the system.


Since Java 5, the Java concurrency API provides a mechanism that aims at resolving
problems. This mechanism is called the Executor framework and is around the  Executor
interface, its subinterface  ExecutorService , and the  ThreadPoolExecutor class that
implements both interfaces.


This mechanism separates the task creation and its execution. With an executor, you only
have to implement the  Runnable objects and send them to the executor. It is responsible for
their execution, instantiation, and running with necessary threads. But it goes beyond that and
improves performance using a pool of threads. When you send a task to the executor, it tries to
use a pooled thread for the execution of this task, to avoid continuous spawning of threads.
Another important advantage of the Executor framework is the  Callable interface. It's
similar to the  Runnable interface, but offers two improvements, which are as follows:

- The main method of this interface, named  call() , may return a result.

- When you send a  Callable object to an executor, you get an object that implements the  Future interface. You can use this object to control the status and the result of
the  Callable object.


## Creating a thread executor

- Main.java

```java
/**
 * Main class of the example. Creates a server and 100 request of the Task class
 * that sends to the server
 *
 */
public class Main {

	/**
	 * Main method of the example
	 * @param args
	 */
	public static void main(String[] args) {
		// Create the server
		Server server=new Server();
		
		// Send 100 request to the server and finish
		for (int i=0; i<100; i++){
			Task task=new Task("Task "+i);
			server.executeTask(task);
		}
		
		server.endServer();

	}

}
```

- Server.java

```java
/**
 * This class simulates a server, for example, a web server, that receives
 * requests and uses a ThreadPoolExecutor to execute those requests
 *
 */
public class Server {
	
	/**
	 * ThreadPoolExecutors to manage the execution of the request
	 */
	private ThreadPoolExecutor executor;
	
	/**
	 * Constructor of the class. Creates the executor object
	 */
	public Server(){
		executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
	}
	
	/**
	 * This method is called when a request to the server is made. The 
	 * server uses the executor to execute the request that it receives
	 * @param task The request made to the server
	 */
	public void executeTask(Task task){
		System.out.printf("Server: A new task has arrived\n");
		executor.execute(task);
		System.out.printf("Server: Pool Size: %d\n",executor.getPoolSize());
		System.out.printf("Server: Active Count: %d\n",executor.getActiveCount());
		System.out.printf("Server: Completed Tasks: %d\n",executor.getCompletedTaskCount());
	}

	/**
	 * This method shuts down the executor
	 */
	public void endServer() {
		executor.shutdown();
	}

}
```

- Task.java

```java
/**
 * This class implements a concurrent task 
 *
 */
public class Task implements Runnable {

	/**
	 * The start date of the task
	 */
	private Date initDate;
	/**
	 * The name of the task
	 */
	private String name;
	
	/**
	 * Constructor of the class. Initializes the name of the task
	 * @param name name asigned to the task
	 */
	public Task(String name){
		initDate=new Date();
		this.name=name;
	}
	
	/**
	 * This method implements the execution of the task. Waits a random period of time and finish
	 */
	@Override
	public void run() {
		System.out.printf("%s: Task %s: Created on: %s\n",Thread.currentThread().getName(),name,initDate);
		System.out.printf("%s: Task %s: Started on: %s\n",Thread.currentThread().getName(),name,new Date());
		
		try {
			Long duration=(long)(Math.random()*10);
			System.out.printf("%s: Task %s: Doing a task during %d seconds\n",Thread.currentThread().getName(),name,duration);
			TimeUnit.SECONDS.sleep(duration);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		System.out.printf("%s: Task %s: Finished on: %s\n",Thread.currentThread().getName(),name,new Date());
	}

}
```

- 输出结果: 用`Executors.newCachedThreadPool()` 模拟了100个线程运行,最后用`executor.shutdown();` 来关闭

- 使用newCachedThreadPool的原因

Use the executor created by the newCachedThreadPool() method
only when you have a reasonable number of threads or when they
have a short duration.

- 线程池关闭的时间

If you want to wait for the completion of the tasks, regardless of their
duration, use a big timeout, for example, DAYS.


## Creating a fixed-size thread executor

- Main.java

```java
/**
 * Main class of the example. Creates a server and 100 request of the Task class
 * that sends to the server
 *
 */
public class Main {

	/**
	 * Main method of the example
	 * @param args
	 */
	public static void main(String[] args) {
		// Create the server
		Server server=new Server();
		
		// Send 100 request to the server and finish		
		for (int i=0; i<100; i++){
			Task task=new Task("Task "+i);
			server.executeTask(task);
		}
		
		server.endServer();

	}

}
```

- Server.java

```java
/**
 * This class simulates a server, for example, a web server, that receives
 * requests and uses a ThreadPoolExecutor to execute those requests
 *
 */
public class Server {

	/**
	 * ThreadPoolExecutors to manage the execution of the request
	 */
	private ThreadPoolExecutor executor;
	
	/**
	 * Constructor of the class. Creates the executor object
	 */
	public Server(){
		executor=(ThreadPoolExecutor)Executors.newFixedThreadPool(5);
	}
	
	/**
	 * This method is called when a request to the server is made. The 
	 * server uses the executor to execute the request that it receives
	 * @param task The request made to the server
	 */
	public void executeTask(Task task){
		System.out.printf("Server: A new task has arrived\n");
		executor.execute(task);
		System.out.printf("Server: Pool Size: %d\n",executor.getPoolSize());
		System.out.printf("Server: Active Count: %d\n",executor.getActiveCount());
		System.out.printf("Server: Task Count: %d\n",executor.getTaskCount());
		System.out.printf("Server: Completed Tasks: %d\n",executor.getCompletedTaskCount());
	}

	/**
	 * This method shuts down the executor
	 */
	public void endServer() {
		executor.shutdown();
	}

}
```

- Task.java

```java
/**
 * This class implements a concurrent task
 *
 */
public class Task implements Runnable {

	/**
	 * The start date of the task
	 */
	private Date initDate;
	
	/**
	 * The name of the task
	 */
	private String name;
	
	/**
	 * Constructor of the class. Initializes the name of the task
	 * @param name Name assigned to the task
	 */
	public Task(String name){
		initDate=new Date();
		this.name=name;
	}
	
	/**
	 * This method implements the execution of the task. Waits a random period of time and finish
	 */	
	@Override
	public void run() {
		System.out.printf("%s: Task %s: Created on: %s\n",Thread.currentThread().getName(),name,initDate);
		System.out.printf("%s: Task %s: Started on: %s\n",Thread.currentThread().getName(),name,new Date());
		
		try {
			Long duration=(long)(Math.random()*10);
			System.out.printf("%s: Task %s: Doing a task during %d seconds\n",Thread.currentThread().getName(),name,duration);
			TimeUnit.SECONDS.sleep(duration);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		System.out.printf("%s: Task %s: Finished on: %s\n",Thread.currentThread().getName(),new Date(),name);
	}

}
```

- 输出结果: 输出效果和上一个例子是一样的,只不过在创建线程池的时候用newFixedThreadPool


When you use basic  ThreadPoolExecutor created with the  newCachedThreadPool()
method of the  Executors class, you can have a problem with the number of threads the
executor is running at a time. The executor creates a new thread for each task that receives,
(if there is no pooled thread free) so, if you send a large number of tasks and they have long
duration, you can overload the system and provoke a poor performance of your application.


If you want to avoid this problem, the  Executors class provides a method to create a
fixed-size thread executor. This executor has a maximum number of threads. If you send
more tasks than the number of threads, the executor won't create additional threads and
the remaining tasks will be blocked until the executor has a free thread. With this behavior,
you guarantee that the executor won't yield a poor performance of your application.

- newSingleThreadExecutor()线程池

The  Executors class also provides the  newSingleThreadExecutor() method. This is an
extreme case of a fixed-size thread executor. It creates an executor with only one thread, so it
can only execute one task at a time.

## Executing tasks in an executor that returns a result


One of the advantages of the Executor framework is that you can run concurrent tasks that
return a result. The Java Concurrency API achieves this with the following two interfaces:

- Callable : This interface has the  call() method. In this method, you have to implement the logic of a task. The  Callable interface is a parameterized interface,meaning you have to indicate the type of data the  call() method will return.

- Future : This interface has some methods to obtain the result generated by a Callable object and to manage its state.


- Main.java

```java
/**
 * Main class of the example. Creates and execute ten FactorialCalculator tasks
 * in an executor controlling when they finish to write the results calculated
 *
 */
public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		// Create a ThreadPoolExecutor with fixed size. It has a maximun of two threads
		ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newFixedThreadPool(2);
		// List to store the Future objects that control the execution of  the task and
		// are used to obtain the results
		List<Future<Integer>> resultList=new ArrayList<>();

		// Create a random number generator
		Random random=new Random();
		// Create and send to the executor the ten tasks
		for (int i=0; i<10; i++){
			Integer number=new Integer(random.nextInt(10));
			FactorialCalculator calculator=new FactorialCalculator(number);
			Future<Integer> result=executor.submit(calculator);
			resultList.add(result);
		}
		
		// Wait for the finalization of the ten tasks
		do {
			System.out.printf("Main: Number of Completed Tasks: %d\n",executor.getCompletedTaskCount());
			for (int i=0; i<resultList.size(); i++) {
				Future<Integer> result=resultList.get(i);
				System.out.printf("Main: Task %d: %s\n",i,result.isDone());
			}
			try {
				Thread.sleep(50);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		} while (executor.getCompletedTaskCount()<resultList.size());
		
		// Write the results
		System.out.printf("Main: Results\n");
		for (int i=0; i<resultList.size(); i++) {
			Future<Integer> result=resultList.get(i);
			Integer number=null;
			try {
				number=result.get();
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
			System.out.printf("Core: Task %d: %d\n",i,number);
		}
		
		// Shutdown the executor
		executor.shutdown();

	}

}
```

- FactorialCalculator.java

```java
/**
 * 
 * This class calculates the factorial of a number. It can be executed
 * in an executor because it implements de Callable interface.
 * The call method() will return an Interger
 *
 */
public class FactorialCalculator implements Callable<Integer> {

	/**
	 * Number to calculate the factorial
	 */
	private Integer number;
	
	/**
	 * Constructor of the class. Initializes the attributes
	 * @param number Number to calculate the factorial
	 */
	public FactorialCalculator(Integer number){
		this.number=number;
	}
	
	/**
	 * Method called by the executor to execute this task and calculate the factorial of a
	 * number
	 */
	@Override
	public Integer call() throws Exception {
		int num, result;
		
		num=number.intValue();
		result=1;
		
		// If the number is 0 or 1, return the 1 value
		if ((num==0)||(num==1)) {
			result=1;
		} else {
			// Else, calculate the factorial
			for (int i=2; i<=number; i++) {
				result*=i;
				Thread.sleep(20);
			}
		}
		System.out.printf("%s: %d\n",Thread.currentThread().getName(),result);
		// Return the value
		return result;
	}
}
```


- 输出结果: 计算整数的阶乘,使用了`Callable<Integer>`,线程池运行后可以用`Future<Integer> result=resultList.get(i);`取到运行的结果,重写call()方法

## Running multiple tasks and processing the first result

A common problem in concurrent programming is when you have various concurrent tasks
that solve a problem, and you are only interested in the first result of those tasks. For
example, you want to sort an array. You have various sort algorithms. You can launch all of
them and get the result of the first one that sorts these, that is, the fastest sorting algorithm
for a given array.


- Main.java

```java
/**
 * This is the main class of the example. Creates two user validation systems and execute
 * them in an Executor using the invokeAny() method. If the user is validated by one of the
 * user validation systems, then it shows a message. If both system don't validate the user,
 * the application proccess the ExecutionException throwed by the method
 */
public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		// Initialize the parameters of the user
		String username="test";
		String password="test";
		
		// Create two user validation objects
		UserValidator ldapValidator=new UserValidator("LDAP");
		UserValidator dbValidator=new UserValidator("DataBase");
		
		// Create two tasks for the user validation objects
		TaskValidator ldapTask=new TaskValidator(ldapValidator, username, password);
		TaskValidator dbTask=new TaskValidator(dbValidator,username,password);
		
		// Add the two tasks to a list of tasks
		List<TaskValidator> taskList=new ArrayList<>();
		taskList.add(ldapTask);
		taskList.add(dbTask);
		
		// Create a new Executor
		ExecutorService executor=(ExecutorService)Executors.newCachedThreadPool();
		String result;
		try {
			// Send the list of tasks to the executor and waits for the result of the first task 
			// that finish without throw and Exception. If all the tasks throw and Exception, the
			// method throws and ExecutionException.
			result = executor.invokeAny(taskList);
			System.out.printf("Main: Result: %s\n",result);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (ExecutionException e) {
			e.printStackTrace();
		}
		
		// Shutdown the Executor
		executor.shutdown();
		System.out.printf("Main: End of the Execution\n");
	}

}

```

- TaskValidator.java

```java
/**
 * This class encapsulate a user validation system to be executed as a Callable object.
 * If the user is validated, it returns the name of the validation system. If not,
 * it throws an Exception
 *
 */
public class TaskValidator implements Callable<String> {

	/**
	 * The user validator used to validate the user.
	 */
	private UserValidator validator;
	/**
	 * The name of the user
	 */
	private String user;
	/**
	 * The password of the user
	 */
	private String password;
	
	/**
	 * Constructor of the class
	 * @param validator The user validator system used to validate it 
	 * @param user The name of the user
	 * @param password The password of the user
	 */
	public TaskValidator(UserValidator validator, String user, String password){
		this.validator=validator;
		this.user=user;
		this.password=password;
	}
	
	/**
	 * Core method of the Callable interface. Tries to validate the user using the user
	 * validation system. If the user is validated, returns the name of the validation system. 
	 * If not, throws and Exception
	 * @return The name of the user validation system.
	 * @throws Exception An exception when the user is not validated
	 */
	@Override
	public String call() throws Exception {
		if (!validator.validate(user, password)) {
			System.out.printf("%s: The user has not been found\n",validator.getName());
			throw new Exception("Error validating user");
		}
		System.out.printf("%s: The user has been found\n",validator.getName());
		return validator.getName();
	}

}
```

- UserValidator.java

```java
/**
 * This class implement a simulation of a user validation system. It suspend the Thread
 * a random period of time and then returns a random boolean value. We consider that it
 * returns the true value when the user is validated and the false value when it's not
 *
 */
public class UserValidator {
	
	/**
	 * The name of the validation system
	 */
	private String name;
	
	/**
	 * Constructor of the class
	 * @param name The name of the user validation system
	 */
	public UserValidator(String name) {
		this.name=name;
	}
	
	/**
	 * Method that validates a user
	 * @param name Name of the user
	 * @param password Password of the user
	 * @return true if the user is validated and false if not
	 */
	public boolean validate(String name, String password) {
		// Create a new Random objects generator
		Random random=new Random();
		
		// Sleep the thread during a random period of time
		try {
			Long duration=(long)(Math.random()*10);
			System.out.printf("Validator %s: Validating a user during %d seconds\n",this.name,duration);
			TimeUnit.SECONDS.sleep(duration);
		} catch (InterruptedException e) {
			return false;
		}
		
		// Return a random boolean value
		return random.nextBoolean();
	}
	
	/**
	 * Return the name of the validation system
	 * @return The name of the validation system
	 */
	public String getName(){
		return name;
	}

}
```

- 输出结果: 同样调用了`Callable<String>`, 但这里调用返回结果时用的是`result = executor.invokeAny(taskList);`,关于它的解释可以看下面


The key of the example is in the  Main class. The  invokeAny() method of the
ThreadPoolExecutor class receives a list of tasks, launches them, and returns the result
of the first task that finishes without throwing an exception. This method returns the same
data type that the  call() method of the tasks you launch returns. In this case, it returns a
String value.

## Running multiple tasks and processing all the results

- Main.java

```java
/**
 * Main class of the example. Launch three tasks using the invokeAll() method
 * and then prints their results to the console
 *
 */
public class Main {

	public static void main(String[] args) {

		// Create an executor
		ExecutorService executor=(ExecutorService)Executors.newCachedThreadPool();

		// Create three tasks and stores them in a List
		List<Task> taskList=new ArrayList<>();
		for (int i=0; i<3; i++){
			Task task=new Task("Task-"+i);
			taskList.add(task);
		}

		// Call the invokeAll() method
		List<Future<Result>>resultList=null;
		try {
			resultList=executor.invokeAll(taskList);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		// Finish the executor
		executor.shutdown();
		
		// Writes the results to the console
		System.out.printf("Core: Printing the results\n");
		for (int i=0; i<resultList.size(); i++){
			Future<Result> future=resultList.get(i);
			try {
				Result result=future.get();
				System.out.printf("%s: %s\n",result.getName(),result.getValue());
			} catch (InterruptedException | ExecutionException e) {
				e.printStackTrace();
			} 
		}
	}

}
```

- Result.java

```java
/**
 * This class stores the result generated by one task
 *
 */
public class Result {
	/**
	 * The name of the task that generates the result
	 */
	private String name;
	/**
	 * The value of the task that generates the result 
	 */
	private int value;
	
	/**
	 * Returns the name of the task
	 * @return Name of the task that generates the result
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * Establish the name of the task
	 * @param name The name of the task that generates the result
	 */
	public void setName(String name) {
		this.name = name;
	}
	
	/**
	 * Returns the value of the result
	 * @return The value of the result
	 */
	public int getValue() {
		return value;
	}
	
	/**
	 * Establish the value of the result
	 * @param value The value of the result
	 */
	public void setValue(int value) {
		this.value = value;
	}
	
}
```

- Task.java

```java
/**
 * This class implements the task of this example. It waits during a random
 * period of time and then calculate the sum of five random numbers 
 *
 */
public class Task implements Callable<Result> {

	/**
	 * The name of the Task
	 */
	private String name;
	
	/**
	 * Constructor of the class
	 * @param name Initializes the name of the task
	 */
	public Task(String name) {
		this.name=name;
	}
	
	/**
	 * Main method of the task. Waits during a random period of time and then
	 * calculates the sum of five random numbers
	 */
	@Override
	public Result call() throws Exception {
		// Writes a message to the console
		System.out.printf("%s: Staring\n",this.name);
		
		// Waits during a random period of time
		try {
			Long duration=(long)(Math.random()*10);
			System.out.printf("%s: Waiting %d seconds for results.\n",this.name,duration);
			TimeUnit.SECONDS.sleep(duration);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}		
		
		// Calculates the sum of five random numbers
		int value=0;
		for (int i=0; i<5; i++){
			value+=(int)(Math.random()*100);

		}
		
		// Creates the object with the results
		Result result=new Result();
		result.setName(this.name);
		result.setValue(value);
		System.out.printf("%s: Ends\n",this.name);

		// Returns the result object
		return result;
	}

}
```

- 输出结果: 和上一个示例一样,唯一的区别在于接受返回的结果变成了`resultList=executor.invokeAll(taskList);`


The first point to take into consideration is that the type of data used for the parameterization
of the  Future interface in the declaration of the list that stores the result objects must be
compatible with the one used to parameterized the  Callable objects. In this case, you have
used the same type of data: the  Result class.
Another important point about the  invokeAll() method is that you will use the  Future
objects only to get the results of the tasks. As the method finishes when all the tasks have
finished, if you call the  isDone() method of the  Future objects that is returned, all the calls
will return the  true value.

## Running a task in an executor after a delay

- Main.java

```java
/**
 * Main class of the example. Send 5 tasks to an scheduled executor
 *   Task 0: Delay of 1 second
 *   Task 1: Delay of 2 seconds
 *   Task 2: Delay of 3 seconds
 *   Task 3: Delay of 4 seconds
 *   Task 4: Delay of 5 seconds 
 *
 */
public class Main {

	/**
	 * Main method of the example
	 * @param args
	 */
	public static void main(String[] args) {

		// Create a ScheduledThreadPoolExecutor
		ScheduledExecutorService executor=(ScheduledExecutorService)Executors.newScheduledThreadPool(1);
		
		System.out.printf("Main: Starting at: %s\n",new Date());
		
		// Send the tasks to the executor with the specified delay
		for (int i=0; i<5; i++) {
			Task task=new Task("Task "+i);
			executor.schedule(task,i+1 , TimeUnit.SECONDS);
		}
		
		// Finish the executor
		executor.shutdown();
		
		// Waits for the finalization of the executor
		try {
			executor.awaitTermination(1, TimeUnit.DAYS);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		// Writes the finalization message
		System.out.printf("Core: Ends at: %s\n",new Date());
	}
}
```

- Task.java

```java
/**
 * This class implements the task of this example. Writes a
 * message to the console with the actual date and returns the
 * 'Hello, world' string
 *
 */
public class Task implements Callable<String> {

	/**
	 * Name of the task
	 */
	private String name;
	
	/**
	 * Constructor of the class
	 * @param name Name of the task
	 */
	public Task(String name) {
		this.name=name;
	}
	
	/**
	 * Main method of the task. Writes a message to the console with
	 * the actual date and returns the 'Hello world' string
	 */
	@Override
	public String call() throws Exception {
		System.out.printf("%s: Starting at : %s\n",name,new Date());
		return "Hello, world";
	}

}
```

- 输出结果: 每隔一秒开始一个任务,使用`ScheduledExecutorService executor=(ScheduledExecutorService)Executors.newScheduledThreadPool(1);`和`executor.schedule(task,i+1 , TimeUnit.SECONDS);`

- 如果关闭线程池的时间和延迟运行线程的时间有冲突的时候:

Finally, you can configure the behavior of the  ScheduledThreadPoolExecutor
class when you call the  shutdown() method and there are pending tasks waiting for
the end of their delay time. The default behavior is that those tasks will be executed
despite the finalization of the executor. You can change this behavior using the
setExecuteExistingDelayedTasksAfterShutdownPolicy() method of the
ScheduledThreadPoolExecutor class. With  false , at the time of  shutdown() ,
pending tasks won't get executed.

## Running a task in an executor periodically

- Main.java

```java
/**
 * Main class of the example. Send a task to the executor that will execute every
 * two seconds. Then, control the remaining time for the next execution of the task 
 *
 */
public class Main {

	/**
	 * Main method of the class
	 * @param args
	 */
	public static void main(String[] args) {
		
		// Create a ScheduledThreadPoolExecutor
		ScheduledExecutorService executor=Executors.newScheduledThreadPool(1);
		System.out.printf("Main: Starting at: %s\n",new Date());

		// Create a new task and sends it to the executor. It will start with a delay of 1 second and then
		// it will execute every two seconds
		Task task=new Task("Task");
		ScheduledFuture<?> result=executor.scheduleAtFixedRate(task, 1, 2, TimeUnit.SECONDS);
		
		// Controlling the execution of tasks
		for (int i=0; i<10; i++){
			System.out.printf("Main: Delay: %d\n",result.getDelay(TimeUnit.MILLISECONDS));
			try {
				TimeUnit.MILLISECONDS.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		
		// Finish the executor
		executor.shutdown();
		System.out.printf("Main: No more tasks at: %s\n",new Date());
		// Verify that the periodic tasks no is in execution after the executor shutdown()
		try {
			TimeUnit.SECONDS.sleep(5);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		// The example finish
		System.out.printf("Main: Finished at: %s\n",new Date());
		
	}

}
```

- Task.java

```java
/**
 * This class implements the task of the example. Writes a message to
 * the console with the actual date. 
 * 
 *  Is used to explain the utilization of an scheduled executor to
 *  execute tasks periodically
 *
 */
public class Task implements Runnable {

	/**
	 * Name of the task
	 */
	private String name;
	
	/**
	 * Constructor of the class
	 * @param name the name of the class
	 */
	public Task(String name) {
		this.name=name;
	}

	/**
	 * Main method of the example. Writes a message to the console with the actual
	 * date
	 */
	@Override
	public void run() {
		System.out.printf("%s: Executed at: %s\n",name,new Date());
	}

}

```


- 输出结果: 比上面运行的时间上更加灵活:`ScheduledFuture<?> result=executor.scheduleAtFixedRate(task, 1, 2, TimeUnit.SECONDS)`, 取得运行结果时用`result.getDelay(TimeUnit.MILLISECONDS)`

- 可以定制两个线程之间的间隔时间,如果间隔时间小于每个线程自己运行的时间的话会怎么样? (执行两遍!)

An important point to consider is that the period between two executions is the period of time
between these two executions that begins. If you have a periodic task that takes 5 sceconds
to execute and you put a period of 3 seconds, you will have two instances of the task
executing at a time.

The method  scheduleAtFixedRate() returns a  ScheduledFuture object, which extends
the  Future interface, with methods to work with scheduled tasks.  ScheduledFuture is
a parameterized interface. In this example, as your task is a  Runnable object that is not
parameterized, you have to parameterize them with the  ? symbol as a parameter.

You have used one method of the  ScheduledFuture interface. The  getDelay() method
returns the time until the next execution of the task. This method receives a  TimeUnit
constant with the time unit in which you want to receive the results.



## Canceling a task in an executor

- Main.java

```java
/**
 * Main class of the example. Execute a task trough an executor, waits
 * 2 seconds and then cancel the task.
 *
 */
public class Main {

	/**
	 * Main method of the class
	 * @param args
	 */
	public static void main(String[] args) {
		
		// Create an executor
		ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
		
		// Create a task
		Task task=new Task();
		
		System.out.printf("Main: Executing the Task\n");

		// Send the task to the executor
		Future<String> result=executor.submit(task);
		
		// Sleep during two seconds
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		// Cancel the task, finishing its execution
		System.out.printf("Main: Cancelling the Task\n");
		result.cancel(true);
		// Verify that the task has been cancelled
		System.out.printf("Main: Cancelled: %s\n",result.isCancelled());
		System.out.printf("Main: Done: %s\n",result.isDone());
		
		// Shutdown the executor
		executor.shutdown();
		System.out.printf("Main: The executor has finished\n");
	}

}
```

- Task.java

```java
/**
 * This class implements the task of the example. It simply writes a message
 * to the console every 100 milliseconds 
 *
 */
public class Task implements Callable<String> {

	/**
	 * Main method of the task. It has an infinite loop that writes a message to
	 * the console every 100 milliseconds
	 */
	@Override
	public String call() throws Exception {
		while (true){
			System.out.printf("Task: Test\n");
			Thread.sleep(100);
		}
	}
}
```

- 输出结果:  模拟线程是的取消操作,`Future<String> result=executor.submit(task);`之后,就可以用`result.cancel(true);`

- 如果取消操作的时候,线程将要运行?正在运行?无法被取消?怎么办

- If the task has finished or has been canceled earlier or it can't be canceled for other reasons, the method will return the  false value and the task won't be canceled.

- If the task is waiting in the executor to get a  Thread object that will execute it, the task is canceled and never begins its execution. If the task is already running, it depends on the parameter of the method. The  cancel() method receives a Boolean value as a parameter. If the value of that parameter is  true and the task is running, it will be canceled. If the value of the parameter is  false and the task is running, it won't be canceled.

- If you use the  get() method of a  Future object that controls a task that has been canceled,
the  get() method will throw a  CancellationException exception

## Controlling a task finishing in an executor

- 使用场景


The  FutureTask class provides a method called  done() that allows you to execute some
code after the finalization of a task executed in an executor. It can be used to make some
post-process operations, generating a report, sending results by e-mail, or releasing some
resources. This method is called internally by the  FutureTask class when the execution of
the task that this  FutureTask object is controlling finishes. The method is called after the
result of the task is set and its status is changed to the  isDone status, regardless of whether
the task has been canceled or finished normally.

By default, this method is empty. You can override the  FutureTask class and implement this
method to change this behavior. In this recipe, you will learn how to override this method to
execute code after the finalization of the tasks.

- Main.java

```java
/**
 * Main class of the example. Creates five tasks that wait a random period of time.
 * Waits 5 seconds and cancel all the tasks. Then, write the results of that tasks
 * that haven't been cancelled.
 *
 */
public class Main {

	/**
	 * Main method of the class.
	 * @param args
	 */
	public static void main(String[] args) {
		// Create an executor
		ExecutorService executor=(ExecutorService)Executors.newCachedThreadPool();
		
		//Create five tasks
		ResultTask resultTasks[]=new ResultTask[5];
		for (int i=0; i<5; i++) {
			ExecutableTask executableTask=new ExecutableTask("Task "+i);
			resultTasks[i]=new ResultTask(executableTask);
			executor.submit(resultTasks[i]);
		}
		
		// Sleep the thread five seconds
		try {
			TimeUnit.SECONDS.sleep(5);
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}

		// Cancel all the tasks. In the tasks that have finished before this moment, this
		// cancellation has no effects
		for (int i=0; i<resultTasks.length; i++) {
			resultTasks[i].cancel(true);
		}
		
		// Write the results of those tasks that haven't been cancelled
		for (int i=0; i<resultTasks.length; i++) {
			try {
				if (!resultTasks[i].isCancelled()){
					System.out.printf("%s\n",resultTasks[i].get());
				}
			} catch (InterruptedException | ExecutionException e) {
				e.printStackTrace();
			} 
		}
		// Finish the executor.
		executor.shutdown();

	}

}
```

- ExecutableTask.java

```java
/**
 * This class implements the task of this example. It waits a random period of time
 *
 */
public class ExecutableTask implements Callable<String> {

	/**
	 * The name of the class
	 */
	private String name;
	
	/**
	 * Constructor of the class
	 * @param name The name of the class
	 */
	public ExecutableTask(String name){
		this.name=name;
	}
	
	/**
	 * Main method of the task. It waits a random period of time and returns a message
	 */
	@Override
	public String call() throws Exception {
		try {
			Long duration=(long)(Math.random()*10);
			System.out.printf("%s: Waiting %d seconds for results.\n",this.name,duration);
			TimeUnit.SECONDS.sleep(duration);
		} catch (InterruptedException e) {
		}		
		return "Hello, world. I'm "+name;
	}

	/**
	 * This method returns the name of the task
	 * @return The name of the task
	 */
	public String getName(){
		return name;
	}
}
```

- ResultTask.java

```java
/**
 * This class manage the execution of a ExecutableTaks. Overrides
 * the done() method that is called when the task finish its execution 
 *
 */
public class ResultTask extends FutureTask<String> {

	/**
	 * Name of the ResultTask. It's initialized with the name of the
	 * ExecutableTask that manages
	 */
	private String name;
	
	/**
	 * Constructor of the Class. Override one of the constructor of its parent class 
	 * @param callable The task this object manages
	 */
	public ResultTask(Callable<String> callable) {
		super(callable);
		this.name=((ExecutableTask)callable).getName();
	}

	/**
	 * Method that is called when the task finish.
	 */
	@Override
	protected void done() {
		if (isCancelled()) {
			System.out.printf("%s: Has been cancelled\n",name);
		} else {
			System.out.printf("%s: Has finished\n",name);
		}
	}

}
```

- 输出结果: 模拟5个任务中,有一个任务完成之后需要通知一下,使用`FutureTask<String>` 并且需要重写`done()`方法


The  done() method is called by the  FutureTask class when the task that is being controlled
finishes its execution. In this example, you have implemented a  Callable object, the
ExecutableTask class, and then, a subclass of the  FutureTask class that controls the
execution of the  ExecutableTask objects.

The  done() method is called internally by the  FutureTask class after establishing the
return value and changing the status of the task to the  isDone status. You can't change the
result value of the task or change its status, but you can close resources used by the task,
write log messages, or send notifications.

## Separating the launching of tasks and the processing of their results in an executor

- 使用场景

Normally, when you execute concurrent tasks using an executor, you will send  Runnable
or  Callable tasks to the executor and get  Future objects to control the method. You can
find situations, where you need to send the tasks to the executor in one object and process
the results in another one. For such situations, the Java Concurrency API provides the
CompletionService class.

This  CompletionService class has a method to send the tasks to an executor and a
method to get the  Future object for the next task that has finished its execution. Internally,
it uses an  Executor object to execute the tasks. This behavior has the advantage to share
a  CompletionService object, and sends tasks to the executor so the others can process
the results. The limitation is that the second object can only get the  Future objects for those
tasks that have finished its execution, so these  Future objects can only be used to get the
results of the tasks.

- Main.java

```java
/**
 * Main class of the example creates all the necessary objects and throws the tasks
 *
 */
public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// Create the executor and thee CompletionService using that executor
		ExecutorService executor=(ExecutorService)Executors.newCachedThreadPool();
		CompletionService<String> service=new ExecutorCompletionService<>(executor);

		// Crete two ReportRequest objects and two Threads to execute them
		ReportRequest faceRequest=new ReportRequest("Face", service);
		ReportRequest onlineRequest=new ReportRequest("Online", service);
		Thread faceThread=new Thread(faceRequest);
		Thread onlineThread=new Thread(onlineRequest);
		
		// Create a ReportSender object and a Thread to execute  it
		ReportProcessor processor=new ReportProcessor(service);
		Thread senderThread=new Thread(processor);
		
		// Start the Threads
		System.out.printf("Main: Starting the Threads\n");
		faceThread.start();
		onlineThread.start();
		senderThread.start();
		
		// Wait for the end of the ReportGenerator tasks
		try {
			System.out.printf("Main: Waiting for the report generators.\n");
			faceThread.join();
			onlineThread.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		// Shutdown the executor
		System.out.printf("Main: Shuting down the executor.\n");
		executor.shutdown();
		try {
			executor.awaitTermination(1, TimeUnit.DAYS);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		// End the execution of the ReportSender
		processor.setEnd(true);
		System.out.printf("Main: Ends\n");

	}

}
```

- ReportGenerator.java

```java
/**
 * This class simulates the generation of a report. Is a Callable
 * object that will be executed by the executor inside a 
 * CompletionService
 *
 */
public class ReportGenerator implements Callable<String> {

	/**
	 * The sender of the report
	 */
	private String sender;
	/**
	 * The title of the report
	 */
	private String title;
	
	/**
	 * Constructor of the class. Initializes the two attributes
	 * @param sender The sender of the report
	 * @param title The title of the report
	 */
	public ReportGenerator(String sender, String title){
		this.sender=sender;
		this.title=title;
	}

	/**
	 * Main method of the ReportGenerator. Waits a random period of time
	 * and then generates the report as a String.
	 */
	@Override
	public String call() throws Exception {
		try {
			Long duration=(long)(Math.random()*10);
			System.out.printf("%s_%s: ReportGenerator: Generating a report during %d seconds\n",this.sender,this.title,duration);
			TimeUnit.SECONDS.sleep(duration);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		String ret=sender+": "+title;
		return ret;
	}
	
}
```

- ReportProcessor.java

```java
/**
 * This class will take the results of the ReportGenerator tasks executed through
 * a CompletinoService
 *
 */
public class ReportProcessor implements Runnable {

	/**
	 * CompletionService that executes the ReportGenerator tasks
	 */
	private CompletionService<String> service;
	/**
	 * Variable to store the status of the Object. It will executes until the variable
	 * takes the true value
	 */
	private boolean end;
	
	/**
	 * Constructor of the class. It initializes the attributes of the class
	 * @param service The CompletionService used to execute the ReportGenerator tasks
	 */
	public ReportProcessor (CompletionService<String> service){
		this.service=service;
		end=false;
	}

	/**
	 * Main method of the class. While the variable end is false, it
	 * calls the poll method of the CompletionService and waits 20 seconds
	 * for the end of a ReportGenerator task
	 */
	@Override
	public void run() {
		while (!end){
			try {
				Future<String> result=service.poll(20, TimeUnit.SECONDS);
				if (result!=null) {
					String report=result.get();
					System.out.printf("ReportReceiver: Report Recived: %s\n",report);
				}			
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
		
		System.out.printf("ReportSender: End\n");
	}

	/**
	 * Method that establish the value of the end attribute
	 * @param end New value of the end attribute.
	 */
	public void setEnd(boolean end) {
		this.end = end;
	}
	
	
}
```

- ReportRequest.java

```java
/**
 * This class represents every actor that can request a report. For this example,
 * it simply create three ReportGenerator objects and execute them through a 
 * CompletionService
 *
 */
public class ReportRequest implements Runnable {

	/**
	 * Name of this ReportRequest
	 */
	private String name;
	
	/**
	 * CompletionService used for the execution of the ReportGenerator tasks
	 */
	private CompletionService<String> service;
	
	/**
	 * Constructor of the class. Initializes the parameters
	 * @param name Name of the ReportRequest
	 * @param service Service used for the execution of tasks
	 */
	public ReportRequest(String name, CompletionService<String> service){
		this.name=name;
		this.service=service;
	}

	/**
	 * Main method of the class. Create three ReportGenerator tasks and executes them
	 * through a CompletionService
	 */
	@Override
	public void run() {
			ReportGenerator reportGenerator=new ReportGenerator(name, "Report");
			service.submit(reportGenerator);
	}

}
```

- 输出结果: 总共有3个线程,分别是面对面线程,上网线程,接受报告线程,接受报告线程会接受其他两个线程的结果



In the main class of the example, you have created  ThreadPoolExecutor using the
newCachedThreadPool() method of the  Executors class. Then, you have used that
object to initialize a  CompletionService object because the completion service uses an
executor to execute its tasks. To execute a task using the completion service, you use the
submit() method as in the  ReportRequest class.


When one of these tasks is executed when the completion service finishes its execution, the
completion service stores the  Future object used to control its execution in a queue. The
poll() method accesses this queue to see if there is any task that has finished its execution
and, if so, returns the first element of that queue which is a  Future object for a task that has
finished its execution. When the  poll() method returns a  Future object, it deletes it from
the queue. In this case, you have passed two attributes to that method to indicate the time
you want to wait for the finalization of a task, in case the queue with the results of the finished tasks is empty.


Once the  CompletionService object is created, you create two  ReportRequest objects
that execute three  ReportGenerator tasks, each one in  CompletionService , and a
ReportSender task that will process the results generated by the tasks sent by the two
ReportRequest objects.

The  CompletionService class can execute  Callable or  Runnable tasks. In this example,
you have used  Callable , but you could also send  Runnable objects. Since  Runnable
objects don't produce a result, the philosophy of the  CompletionService class doesn't
apply in such cases

## Controlling rejected tasks of an executor

- 使用场景: 当你关闭线程池的时候,可以主动拒绝接下来提交的线程

When you want to finish the execution of an executor, you use the  shutdown() method
to indicate that it should finish. The executor waits for the completion of the tasks that are
running or waiting for their execution, and then finishes its execution.


If you send a task to an executor between the  shutdown() method and the end of its
execution, the task is rejected, because the executor no longer accepts new tasks. The
ThreadPoolExecutor class provides a mechanism, which is called when a task is rejected.

- Main.java

```java
/**
 * Main class of the example
 *
 */
public class Main {

	/**
	 * Main method of the example
	 * @param args
	 */
	public static void main(String[] args) {

		// Create the controller for the Rejected tasks
		RejectedTaskController controller=new RejectedTaskController();
		// Create the executor and establish the controller for the Rejected tasks
		ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
		executor.setRejectedExecutionHandler(controller);
		
		// Lauch three tasks
		System.out.printf("Main: Starting.\n");
		for (int i=0; i<3; i++) {
			Task task=new Task("Task"+i);
			executor.submit(task);
		}
		
		// Shutdown the executor
		System.out.printf("Main: Shuting down the Executor.\n");
		executor.shutdown();

		// Send another task
		System.out.printf("Main: Sending another Task.\n");
		Task task=new Task("RejectedTask");
		executor.submit(task);
		
		// The program ends
		System.out.printf("Main: End.\n");
		
	}

}
```

- RejectedTaskController.java

```java
/**
 * This class implements the handler for the rejected tasks. Implements
 * the RejectedExecutionHandler interface and will be called for each task
 * sent to an executor after it was finished using the shutdown() method 
 *
 */
public class RejectedTaskController implements RejectedExecutionHandler {

	/**
	 * Method that will be executed for each rejected task
	 * @param r Task that has been rejected
	 * @param executor Executor that has rejected the task
	 */
	@Override
	public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
		System.out.printf("RejectedTaskController: The task %s has been rejected\n",r.toString());
		System.out.printf("RejectedTaskController: %s\n",executor.toString());
		System.out.printf("RejectedTaskController: Terminating: %s\n",executor.isTerminating());
		System.out.printf("RejectedTaksController: Terminated: %s\n",executor.isTerminated());
	}

}
```

- Task.java

```java
/**
 * This class implements a task executed in this example. It only waits
 * a random perior of time
 *
 */
public class Task implements Runnable{

	/**
	 * Name of the task
	 */
	private String name;

	/**
	 * Constructor of the class. It initializes the attributes of the class
	 * @param name The name of the task
	 */
	public Task(String name){
		this.name=name;
	}
	
	/**
	 * Main method of the task. Waits a random period of time
	 */
	@Override
	public void run() {
		System.out.printf("Task %s: Starting\n",name);
		try {
			Long duration=(long)(Math.random()*10);
			System.out.printf("Task %s: ReportGenerator: Generating a report during %d seconds\n",name,duration);
			TimeUnit.SECONDS.sleep(duration);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}		
		System.out.printf("Task %s: Ending\n",name);
	}

	/**
	 * Returns the name of the task
	 */
	public String toString() {
		return name;
	}
	
}
```

- 输出结果: 先启动了3个线程,不过此时开始主动拒绝,结果这3个线程都没有运行完成,之后就关闭了,使用`RejectedExecutionHandler`,重写`rejectedExecution()`方法


When an executor receives a task to execute, it checks if the  shutdown() method
has been called. If so, it rejects the task. First, it looks for the handler established with
setRejectedExecutionHandler() . If there's one, it calls the  rejectedExecution()
method of that class, otherwise it throws  RejectedExecutionExeption . This is a runtime
exception, so you don't need to put a  catch clause to control it.
