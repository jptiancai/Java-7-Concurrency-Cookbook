<!doctype html public '-//W3C//DTD HTML 4.0 Transitional //EN'>
<html>
<head>
<title>4.Thread Executors</title>
<meta charset='UTF-8' />
<meta name='generator' content='EverEdit' />
<link href='D:\EverEdit\mode\markdown\default.css' rel='stylesheet'></link>
<link href='D:\EverEdit\mode\markdown\prettify.css' rel='stylesheet'></link>
<script type='text/javascript' src='D:\EverEdit\mode\markdown\prettify.js'></script>
<script type='text/javascript' src='D:\EverEdit\mode\markdown\jquery-1.10.2.min.js'></script>
<script type='text/javascript' src='D:\EverEdit\mode\markdown\toc.js'></script>
</head>
<body>
<div id='generated-toc'></div>
<h2>并发编程的缺点</h2>

<p>If you have to develop a program that runs a lot of concurrent tasks, this approach has the
following disadvantages:</p>

<ul>
<li>You have to implement all the code-related information to the management of the Thread objects (creation, ending, obtaining results).</li>
<li><p>You create a  Thread object per task. If you have to execute a big number of tasks, this can affect the throughput of the application.</p></li>
<li><p>You have to control and manage efficiently the resources of the computer.If you create too many threads, you can saturate the system.</p></li>
</ul>

<p>Since Java 5, the Java concurrency API provides a mechanism that aims at resolving
problems. This mechanism is called the Executor framework and is around the  Executor
interface, its subinterface  ExecutorService , and the  ThreadPoolExecutor class that
implements both interfaces.</p>

<p>This mechanism separates the task creation and its execution. With an executor, you only
have to implement the  Runnable objects and send them to the executor. It is responsible for
their execution, instantiation, and running with necessary threads. But it goes beyond that and
improves performance using a pool of threads. When you send a task to the executor, it tries to
use a pooled thread for the execution of this task, to avoid continuous spawning of threads.
Another important advantage of the Executor framework is the  Callable interface. It's
similar to the  Runnable interface, but offers two improvements, which are as follows:</p>

<ul>
<li><p>The main method of this interface, named  call() , may return a result.</p></li>
<li><p>When you send a  Callable object to an executor, you get an object that implements the  Future interface. You can use this object to control the status and the result of
the  Callable object.</p></li>
</ul>

<h2>Creating a thread executor</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example. Creates a server and 100 request of the Task class
 * that sends to the server
 *
 */
public class Main {

    /**
     * Main method of the example
     * @param args
     */
    public static void main(String[] args) {
        // Create the server
        Server server=new Server();

        // Send 100 request to the server and finish
        for (int i=0; i&lt;100; i++){
            Task task=new Task("Task "+i);
            server.executeTask(task);
        }

        server.endServer();

    }

}</code></pre>

<ul>
<li>Server.java</li>
</ul>

<pre><code class="java">/**
 * This class simulates a server, for example, a web server, that receives
 * requests and uses a ThreadPoolExecutor to execute those requests
 *
 */
public class Server {

    /**
     * ThreadPoolExecutors to manage the execution of the request
     */
    private ThreadPoolExecutor executor;

    /**
     * Constructor of the class. Creates the executor object
     */
    public Server(){
        executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
    }

    /**
     * This method is called when a request to the server is made. The 
     * server uses the executor to execute the request that it receives
     * @param task The request made to the server
     */
    public void executeTask(Task task){
        System.out.printf("Server: A new task has arrived\n");
        executor.execute(task);
        System.out.printf("Server: Pool Size: %d\n",executor.getPoolSize());
        System.out.printf("Server: Active Count: %d\n",executor.getActiveCount());
        System.out.printf("Server: Completed Tasks: %d\n",executor.getCompletedTaskCount());
    }

    /**
     * This method shuts down the executor
     */
    public void endServer() {
        executor.shutdown();
    }

}</code></pre>

<ul>
<li>Task.java</li>
</ul>

<pre><code class="java">/**
 * This class implements a concurrent task 
 *
 */
public class Task implements Runnable {

    /**
     * The start date of the task
     */
    private Date initDate;
    /**
     * The name of the task
     */
    private String name;

    /**
     * Constructor of the class. Initializes the name of the task
     * @param name name asigned to the task
     */
    public Task(String name){
        initDate=new Date();
        this.name=name;
    }

    /**
     * This method implements the execution of the task. Waits a random period of time and finish
     */
    @Override
    public void run() {
        System.out.printf("%s: Task %s: Created on: %s\n",Thread.currentThread().getName(),name,initDate);
        System.out.printf("%s: Task %s: Started on: %s\n",Thread.currentThread().getName(),name,new Date());

        try {
            Long duration=(long)(Math.random()*10);
            System.out.printf("%s: Task %s: Doing a task during %d seconds\n",Thread.currentThread().getName(),name,duration);
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.printf("%s: Task %s: Finished on: %s\n",Thread.currentThread().getName(),name,new Date());
    }

}</code></pre>

<ul>
<li><p>输出结果: 用<code>Executors.newCachedThreadPool()</code> 模拟了100个线程运行,最后用<code>executor.shutdown();</code> 来关闭</p></li>
<li><p>使用newCachedThreadPool的原因</p></li>
</ul>

<p>Use the executor created by the newCachedThreadPool() method
only when you have a reasonable number of threads or when they
have a short duration.</p>

<ul>
<li>线程池关闭的时间</li>
</ul>

<p>If you want to wait for the completion of the tasks, regardless of their
duration, use a big timeout, for example, DAYS.</p>

<h2>Creating a fixed-size thread executor</h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java">/**
 * Main class of the example. Creates a server and 100 request of the Task class
 * that sends to the server
 *
 */
public class Main {

    /**
     * Main method of the example
     * @param args
     */
    public static void main(String[] args) {
        // Create the server
        Server server=new Server();

        // Send 100 request to the server and finish        
        for (int i=0; i&lt;100; i++){
            Task task=new Task("Task "+i);
            server.executeTask(task);
        }

        server.endServer();

    }

}</code></pre>

<ul>
<li>Server.java</li>
</ul>

<pre><code class="java">/**
 * This class simulates a server, for example, a web server, that receives
 * requests and uses a ThreadPoolExecutor to execute those requests
 *
 */
public class Server {

    /**
     * ThreadPoolExecutors to manage the execution of the request
     */
    private ThreadPoolExecutor executor;

    /**
     * Constructor of the class. Creates the executor object
     */
    public Server(){
        executor=(ThreadPoolExecutor)Executors.newFixedThreadPool(5);
    }

    /**
     * This method is called when a request to the server is made. The 
     * server uses the executor to execute the request that it receives
     * @param task The request made to the server
     */
    public void executeTask(Task task){
        System.out.printf("Server: A new task has arrived\n");
        executor.execute(task);
        System.out.printf("Server: Pool Size: %d\n",executor.getPoolSize());
        System.out.printf("Server: Active Count: %d\n",executor.getActiveCount());
        System.out.printf("Server: Task Count: %d\n",executor.getTaskCount());
        System.out.printf("Server: Completed Tasks: %d\n",executor.getCompletedTaskCount());
    }

    /**
     * This method shuts down the executor
     */
    public void endServer() {
        executor.shutdown();
    }

}</code></pre>

<ul>
<li>Task.java</li>
</ul>

<pre><code class="java">/**
 * This class implements a concurrent task
 *
 */
public class Task implements Runnable {

    /**
     * The start date of the task
     */
    private Date initDate;

    /**
     * The name of the task
     */
    private String name;

    /**
     * Constructor of the class. Initializes the name of the task
     * @param name Name assigned to the task
     */
    public Task(String name){
        initDate=new Date();
        this.name=name;
    }

    /**
     * This method implements the execution of the task. Waits a random period of time and finish
     */ 
    @Override
    public void run() {
        System.out.printf("%s: Task %s: Created on: %s\n",Thread.currentThread().getName(),name,initDate);
        System.out.printf("%s: Task %s: Started on: %s\n",Thread.currentThread().getName(),name,new Date());

        try {
            Long duration=(long)(Math.random()*10);
            System.out.printf("%s: Task %s: Doing a task during %d seconds\n",Thread.currentThread().getName(),name,duration);
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.printf("%s: Task %s: Finished on: %s\n",Thread.currentThread().getName(),new Date(),name);
    }

}</code></pre>

<ul>
<li>输出结果: 输出效果和上一个例子是一样的,只不过在创建线程池的时候用newFixedThreadPool</li>
</ul>

<p>When you use basic  ThreadPoolExecutor created with the  newCachedThreadPool()
method of the  Executors class, you can have a problem with the number of threads the
executor is running at a time. The executor creates a new thread for each task that receives,
(if there is no pooled thread free) so, if you send a large number of tasks and they have long
duration, you can overload the system and provoke a poor performance of your application.</p>

<p>If you want to avoid this problem, the  Executors class provides a method to create a
fixed-size thread executor. This executor has a maximum number of threads. If you send
more tasks than the number of threads, the executor won't create additional threads and
the remaining tasks will be blocked until the executor has a free thread. With this behavior,
you guarantee that the executor won't yield a poor performance of your application.</p>

<ul>
<li>newSingleThreadExecutor()线程池</li>
</ul>

<p>The  Executors class also provides the  newSingleThreadExecutor() method. This is an
extreme case of a fixed-size thread executor. It creates an executor with only one thread, so it
can only execute one task at a time.</p>

<h2> </h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
<li>输出结果: </li>
</ul>

<h2> </h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
<li>输出结果: </li>
</ul>

<h2> </h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
<li>输出结果: </li>
</ul>

<h2> </h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
<li>输出结果: </li>
</ul>

<h2> </h2>

<ul>
<li>Main.java</li>
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
- 
</ul>

<pre><code class="java"></code></pre>

<ul>
<li>输出结果: </li>
</ul>
<script type='text/javascript'>
$(document).ready(function(){
  if($('code').length>0){
    $('code').parent().addClass('prettyprint linenums');
    prettyPrint();
};
});
</script>
</body>
</html>