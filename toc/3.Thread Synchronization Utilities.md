## 更高层的机制

- `Semaphores`: A semaphore is a counter that controls the access to one or
more shared resources. This mechanism is one of the basic tools of concurrent
programming and is provided by most of the programming languages.
- `CountDownLatch`: The  CountDownLatch class is a mechanism provided by the Java
language that allows a thread to wait for the finalization of multiple operations.
- `CyclicBarrier`: The  CyclicBarrier class is another mechanism provided by the
Java language that allows the synchronization of multiple threads in a common point.
- `Phaser`: The  Phaser class is another mechanism provided by the Java language that
controls the execution of concurrent tasks divided in phases. All the threads must
finish one phase before they can continue with the next one. This is a new feature of
the Java 7 API.
- `Exchanger`: The  Exchanger class is another mechanism provided by the Java
language that provides a point of data interchange between two threads.

Semaphores are a generic synchronization mechanism that you can use to protect any critical
section in any problem. The other mechanisms are thought to be used in applications with
specific features as it was described previously. Be sure to select the appropriate mechanism
according to the characteristics of your application.

## Controlling concurrent access to a resource

- Main.java

```java
/**
 * Main class of the example.
 *
 */
public class Main {

	/**
	 * Main method of the class. Run ten jobs in parallel that
	 * send documents to the print queue at the same time.
	 */
	public static void main (String args[]){
		
		// Creates the print queue
		PrintQueue printQueue=new PrintQueue();
		
		// Creates ten Threads
		Thread thread[]=new Thread[10];
		for (int i=0; i<10; i++){
			thread[i]=new Thread(new Job(printQueue),"Thread "+i);
		}
		
		// Starts the Threads
		for (int i=0; i<10; i++){
			thread[i].start();
		}
	}

}
```

- Job.java

```java
/**
 * This class simulates a job that send a document to print.
 *
 */
public class Job implements Runnable {

	/**
	 * Queue to print the documents
	 */
	private PrintQueue printQueue;
	
	/**
	 * Constructor of the class. Initializes the queue
	 * @param printQueue
	 */
	public Job(PrintQueue printQueue){
		this.printQueue=printQueue;
	}
	
	/**
	 * Core method of the Job. Sends the document to the print queue and waits
	 *  for its finalization
	 */
	@Override
	public void run() {
		System.out.printf("%s: Going to print a job\n",Thread.currentThread().getName());
		printQueue.printJob(new Object());
		System.out.printf("%s: The document has been printed\n",Thread.currentThread().getName());		
	}
}
```

- PrintQueue.java

```java
/**
 * This class implements the PrintQueue using a Semaphore to control the
 * access to it. 
 *
 */
public class PrintQueue {
	
	/**
	 * Semaphore to control the access to the queue
	 */
	private final Semaphore semaphore;
	
	/**
	 * Constructor of the class. Initializes the semaphore
	 */
	public PrintQueue(){
		semaphore=new Semaphore(1);
	}
	
	/**
	 * Method that simulates printing a document
	 * @param document Document to print
	 */
	public void printJob (Object document){
		try {
			// Get the access to the semaphore. If other job is printing, this
			// thread sleep until get the access to the semaphore
			semaphore.acquire();
			
			Long duration=(long)(Math.random()*10);
			System.out.printf("%s: PrintQueue: Printing a Job during %d seconds\n",Thread.currentThread().getName(),duration);
			Thread.sleep(duration);			
			TimeUnit.SECONDS.sleep(duration);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			// Free the semaphore. If there are other threads waiting for this semaphore,
			// the JVM selects one of this threads and give it the access.
			semaphore.release();			
		}
	}

}
```

- 输出结果: 同样是打印机,这次使用Semaphors来实现

## 

- Main.java

```java
/**
 * Main class of the example.
 *
 */
public class Main {

	/**
	 * Main method of the class. Run ten jobs in parallel that
	 * send documents to the print queue at the same time.
	 */
	public static void main (String args[]){
		
		// Creates the print queue
		PrintQueue printQueue=new PrintQueue();
		
		// Creates ten Threads
		Thread thread[]=new Thread[12];
		for (int i=0; i<12; i++){
			thread[i]=new Thread(new Job(printQueue),"Thread "+i);
		}
		
		// Starts the Threads
		for (int i=0; i<12; i++){
			thread[i].start();
		}
	}

}
```

- Job.java

```java
/**
 * This class simulates a job that send a document to print.
 *
 */
public class Job implements Runnable {

	/**
	 * Queue to print the documents
	 */
	private PrintQueue printQueue;
	
	/**
	 * Constructor of the class. Initializes the queue
	 * @param printQueue
	 */
	public Job(PrintQueue printQueue){
		this.printQueue=printQueue;
	}
	
	/**
	 * Core method of the Job. Sends the document to the print queue and waits
	 *  for its finalization
	 */
	@Override
	public void run() {
		System.out.printf("%s: Going to print a job\n",Thread.currentThread().getName());
		printQueue.printJob(new Object());
		System.out.printf("%s: The document has been printed\n",Thread.currentThread().getName());		
	}
}
```

- PrintQueue.java

```java
/**
 * This class implements a PrintQueue that have access to three printers.
 * 
 * We use a Semaphore to control the access to one of the printers. When
 * a job wants to print, if there is one or more printers free, it has access
 * to one of the free printers. If not, it sleeps until one of the printers
 * is free.
 *
 */
public class PrintQueue {
	
	/**
	 * Semaphore to control the access to the printers
	 */
	private Semaphore semaphore;
	
	/**
	 * Array to control what printer is free
	 */
	private boolean freePrinters[];
	
	/**
	 * Lock to control the access to the freePrinters array
	 */
	private Lock lockPrinters;
	
	/**
	 * Constructor of the class. It initializes the three objects
	 */
	public PrintQueue(){
		semaphore=new Semaphore(3);
		freePrinters=new boolean[3];
		for (int i=0; i<3; i++){
			freePrinters[i]=true;
		}
		lockPrinters=new ReentrantLock();
	}
	
	public void printJob (Object document){
		try {
			// Get access to the semaphore. If there is one or more printers free,
			// it will get the access to one of the printers
			semaphore.acquire();
			
			// Get the number of the free printer
			int assignedPrinter=getPrinter();
			
			Long duration=(long)(Math.random()*10);
			System.out.printf("%s: PrintQueue: Printing a Job in Printer %d during %d seconds\n",Thread.currentThread().getName(),assignedPrinter,duration);
			TimeUnit.SECONDS.sleep(duration);
			
			// Free the printer
			freePrinters[assignedPrinter]=true;
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			// Free the semaphore
			semaphore.release();			
		}
	}

	private int getPrinter() {
		int ret=-1;
		
		try {
			// Get the access to the array
			lockPrinters.lock();
			// Look for the first free printer
			for (int i=0; i<freePrinters.length; i++) {
				if (freePrinters[i]){
					ret=i;
					freePrinters[i]=false;
					break;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			// Free the access to the array
			lockPrinters.unlock();
		}
		return ret;
	}

}
```

- 输出结果: 

## 

- Main.java

```java

```

- 

```java

```

- 

```java

```

- 输出结果: 

## 

- Main.java

```java

```

- 

```java

```

- 

```java

```

- 输出结果: 

## 

- Main.java

```java

```

- 

```java

```

- 

```java

```

- 输出结果: 

## 

- Main.java

```java

```

- 

```java

```

- 

```java

```

- 输出结果: 

## 

- Main.java

```java

```

- 

```java

```

- 

```java

```

- 输出结果: 
